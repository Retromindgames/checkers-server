// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gameconfig"
	"github.com/Lavizord/checkers-server/postgrescli/ent/mathversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/predicate"
	"github.com/Lavizord/checkers-server/postgrescli/ent/session"
)

// MathVersionUpdate is the builder for updating MathVersion entities.
type MathVersionUpdate struct {
	config
	hooks    []Hook
	mutation *MathVersionMutation
}

// Where appends a list predicates to the MathVersionUpdate builder.
func (mvu *MathVersionUpdate) Where(ps ...predicate.MathVersion) *MathVersionUpdate {
	mvu.mutation.Where(ps...)
	return mvu
}

// SetName sets the "name" field.
func (mvu *MathVersionUpdate) SetName(s string) *MathVersionUpdate {
	mvu.mutation.SetName(s)
	return mvu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableName(s *string) *MathVersionUpdate {
	if s != nil {
		mvu.SetName(*s)
	}
	return mvu
}

// SetVersion sets the "version" field.
func (mvu *MathVersionUpdate) SetVersion(s string) *MathVersionUpdate {
	mvu.mutation.SetVersion(s)
	return mvu
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableVersion(s *string) *MathVersionUpdate {
	if s != nil {
		mvu.SetVersion(*s)
	}
	return mvu
}

// SetVolatility sets the "volatility" field.
func (mvu *MathVersionUpdate) SetVolatility(i int) *MathVersionUpdate {
	mvu.mutation.ResetVolatility()
	mvu.mutation.SetVolatility(i)
	return mvu
}

// SetNillableVolatility sets the "volatility" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableVolatility(i *int) *MathVersionUpdate {
	if i != nil {
		mvu.SetVolatility(*i)
	}
	return mvu
}

// AddVolatility adds i to the "volatility" field.
func (mvu *MathVersionUpdate) AddVolatility(i int) *MathVersionUpdate {
	mvu.mutation.AddVolatility(i)
	return mvu
}

// ClearVolatility clears the value of the "volatility" field.
func (mvu *MathVersionUpdate) ClearVolatility() *MathVersionUpdate {
	mvu.mutation.ClearVolatility()
	return mvu
}

// SetRtp sets the "rtp" field.
func (mvu *MathVersionUpdate) SetRtp(i int) *MathVersionUpdate {
	mvu.mutation.ResetRtp()
	mvu.mutation.SetRtp(i)
	return mvu
}

// SetNillableRtp sets the "rtp" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableRtp(i *int) *MathVersionUpdate {
	if i != nil {
		mvu.SetRtp(*i)
	}
	return mvu
}

// AddRtp adds i to the "rtp" field.
func (mvu *MathVersionUpdate) AddRtp(i int) *MathVersionUpdate {
	mvu.mutation.AddRtp(i)
	return mvu
}

// ClearRtp clears the value of the "rtp" field.
func (mvu *MathVersionUpdate) ClearRtp() *MathVersionUpdate {
	mvu.mutation.ClearRtp()
	return mvu
}

// SetMaxWin sets the "max_win" field.
func (mvu *MathVersionUpdate) SetMaxWin(i int) *MathVersionUpdate {
	mvu.mutation.ResetMaxWin()
	mvu.mutation.SetMaxWin(i)
	return mvu
}

// SetNillableMaxWin sets the "max_win" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableMaxWin(i *int) *MathVersionUpdate {
	if i != nil {
		mvu.SetMaxWin(*i)
	}
	return mvu
}

// AddMaxWin adds i to the "max_win" field.
func (mvu *MathVersionUpdate) AddMaxWin(i int) *MathVersionUpdate {
	mvu.mutation.AddMaxWin(i)
	return mvu
}

// ClearMaxWin clears the value of the "max_win" field.
func (mvu *MathVersionUpdate) ClearMaxWin() *MathVersionUpdate {
	mvu.mutation.ClearMaxWin()
	return mvu
}

// SetCanBuyBonus sets the "can_buy_bonus" field.
func (mvu *MathVersionUpdate) SetCanBuyBonus(b bool) *MathVersionUpdate {
	mvu.mutation.SetCanBuyBonus(b)
	return mvu
}

// SetNillableCanBuyBonus sets the "can_buy_bonus" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableCanBuyBonus(b *bool) *MathVersionUpdate {
	if b != nil {
		mvu.SetCanBuyBonus(*b)
	}
	return mvu
}

// ClearCanBuyBonus clears the value of the "can_buy_bonus" field.
func (mvu *MathVersionUpdate) ClearCanBuyBonus() *MathVersionUpdate {
	mvu.mutation.ClearCanBuyBonus()
	return mvu
}

// SetURLReleaseNote sets the "url_release_note" field.
func (mvu *MathVersionUpdate) SetURLReleaseNote(s string) *MathVersionUpdate {
	mvu.mutation.SetURLReleaseNote(s)
	return mvu
}

// SetNillableURLReleaseNote sets the "url_release_note" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableURLReleaseNote(s *string) *MathVersionUpdate {
	if s != nil {
		mvu.SetURLReleaseNote(*s)
	}
	return mvu
}

// ClearURLReleaseNote clears the value of the "url_release_note" field.
func (mvu *MathVersionUpdate) ClearURLReleaseNote() *MathVersionUpdate {
	mvu.mutation.ClearURLReleaseNote()
	return mvu
}

// SetDeprecated sets the "deprecated" field.
func (mvu *MathVersionUpdate) SetDeprecated(b bool) *MathVersionUpdate {
	mvu.mutation.SetDeprecated(b)
	return mvu
}

// SetNillableDeprecated sets the "deprecated" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableDeprecated(b *bool) *MathVersionUpdate {
	if b != nil {
		mvu.SetDeprecated(*b)
	}
	return mvu
}

// SetCanAnteBet sets the "can_ante_bet" field.
func (mvu *MathVersionUpdate) SetCanAnteBet(b bool) *MathVersionUpdate {
	mvu.mutation.SetCanAnteBet(b)
	return mvu
}

// SetNillableCanAnteBet sets the "can_ante_bet" field if the given value is not nil.
func (mvu *MathVersionUpdate) SetNillableCanAnteBet(b *bool) *MathVersionUpdate {
	if b != nil {
		mvu.SetCanAnteBet(*b)
	}
	return mvu
}

// ClearCanAnteBet clears the value of the "can_ante_bet" field.
func (mvu *MathVersionUpdate) ClearCanAnteBet() *MathVersionUpdate {
	mvu.mutation.ClearCanAnteBet()
	return mvu
}

// AddSessionIDs adds the "sessions" edge to the Session entity by IDs.
func (mvu *MathVersionUpdate) AddSessionIDs(ids ...int) *MathVersionUpdate {
	mvu.mutation.AddSessionIDs(ids...)
	return mvu
}

// AddSessions adds the "sessions" edges to the Session entity.
func (mvu *MathVersionUpdate) AddSessions(s ...*Session) *MathVersionUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return mvu.AddSessionIDs(ids...)
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by IDs.
func (mvu *MathVersionUpdate) AddGameConfigIDs(ids ...int) *MathVersionUpdate {
	mvu.mutation.AddGameConfigIDs(ids...)
	return mvu
}

// AddGameConfigs adds the "game_configs" edges to the GameConfig entity.
func (mvu *MathVersionUpdate) AddGameConfigs(g ...*GameConfig) *MathVersionUpdate {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return mvu.AddGameConfigIDs(ids...)
}

// Mutation returns the MathVersionMutation object of the builder.
func (mvu *MathVersionUpdate) Mutation() *MathVersionMutation {
	return mvu.mutation
}

// ClearSessions clears all "sessions" edges to the Session entity.
func (mvu *MathVersionUpdate) ClearSessions() *MathVersionUpdate {
	mvu.mutation.ClearSessions()
	return mvu
}

// RemoveSessionIDs removes the "sessions" edge to Session entities by IDs.
func (mvu *MathVersionUpdate) RemoveSessionIDs(ids ...int) *MathVersionUpdate {
	mvu.mutation.RemoveSessionIDs(ids...)
	return mvu
}

// RemoveSessions removes "sessions" edges to Session entities.
func (mvu *MathVersionUpdate) RemoveSessions(s ...*Session) *MathVersionUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return mvu.RemoveSessionIDs(ids...)
}

// ClearGameConfigs clears all "game_configs" edges to the GameConfig entity.
func (mvu *MathVersionUpdate) ClearGameConfigs() *MathVersionUpdate {
	mvu.mutation.ClearGameConfigs()
	return mvu
}

// RemoveGameConfigIDs removes the "game_configs" edge to GameConfig entities by IDs.
func (mvu *MathVersionUpdate) RemoveGameConfigIDs(ids ...int) *MathVersionUpdate {
	mvu.mutation.RemoveGameConfigIDs(ids...)
	return mvu
}

// RemoveGameConfigs removes "game_configs" edges to GameConfig entities.
func (mvu *MathVersionUpdate) RemoveGameConfigs(g ...*GameConfig) *MathVersionUpdate {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return mvu.RemoveGameConfigIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (mvu *MathVersionUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, mvu.sqlSave, mvu.mutation, mvu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (mvu *MathVersionUpdate) SaveX(ctx context.Context) int {
	affected, err := mvu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (mvu *MathVersionUpdate) Exec(ctx context.Context) error {
	_, err := mvu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (mvu *MathVersionUpdate) ExecX(ctx context.Context) {
	if err := mvu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (mvu *MathVersionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(mathversion.Table, mathversion.Columns, sqlgraph.NewFieldSpec(mathversion.FieldID, field.TypeInt))
	if ps := mvu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := mvu.mutation.Name(); ok {
		_spec.SetField(mathversion.FieldName, field.TypeString, value)
	}
	if value, ok := mvu.mutation.Version(); ok {
		_spec.SetField(mathversion.FieldVersion, field.TypeString, value)
	}
	if value, ok := mvu.mutation.Volatility(); ok {
		_spec.SetField(mathversion.FieldVolatility, field.TypeInt, value)
	}
	if value, ok := mvu.mutation.AddedVolatility(); ok {
		_spec.AddField(mathversion.FieldVolatility, field.TypeInt, value)
	}
	if mvu.mutation.VolatilityCleared() {
		_spec.ClearField(mathversion.FieldVolatility, field.TypeInt)
	}
	if value, ok := mvu.mutation.Rtp(); ok {
		_spec.SetField(mathversion.FieldRtp, field.TypeInt, value)
	}
	if value, ok := mvu.mutation.AddedRtp(); ok {
		_spec.AddField(mathversion.FieldRtp, field.TypeInt, value)
	}
	if mvu.mutation.RtpCleared() {
		_spec.ClearField(mathversion.FieldRtp, field.TypeInt)
	}
	if value, ok := mvu.mutation.MaxWin(); ok {
		_spec.SetField(mathversion.FieldMaxWin, field.TypeInt, value)
	}
	if value, ok := mvu.mutation.AddedMaxWin(); ok {
		_spec.AddField(mathversion.FieldMaxWin, field.TypeInt, value)
	}
	if mvu.mutation.MaxWinCleared() {
		_spec.ClearField(mathversion.FieldMaxWin, field.TypeInt)
	}
	if value, ok := mvu.mutation.CanBuyBonus(); ok {
		_spec.SetField(mathversion.FieldCanBuyBonus, field.TypeBool, value)
	}
	if mvu.mutation.CanBuyBonusCleared() {
		_spec.ClearField(mathversion.FieldCanBuyBonus, field.TypeBool)
	}
	if value, ok := mvu.mutation.URLReleaseNote(); ok {
		_spec.SetField(mathversion.FieldURLReleaseNote, field.TypeString, value)
	}
	if mvu.mutation.URLReleaseNoteCleared() {
		_spec.ClearField(mathversion.FieldURLReleaseNote, field.TypeString)
	}
	if value, ok := mvu.mutation.Deprecated(); ok {
		_spec.SetField(mathversion.FieldDeprecated, field.TypeBool, value)
	}
	if value, ok := mvu.mutation.CanAnteBet(); ok {
		_spec.SetField(mathversion.FieldCanAnteBet, field.TypeBool, value)
	}
	if mvu.mutation.CanAnteBetCleared() {
		_spec.ClearField(mathversion.FieldCanAnteBet, field.TypeBool)
	}
	if mvu.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.SessionsTable,
			Columns: []string{mathversion.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvu.mutation.RemovedSessionsIDs(); len(nodes) > 0 && !mvu.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.SessionsTable,
			Columns: []string{mathversion.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvu.mutation.SessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.SessionsTable,
			Columns: []string{mathversion.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if mvu.mutation.GameConfigsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.GameConfigsTable,
			Columns: []string{mathversion.GameConfigsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(gameconfig.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvu.mutation.RemovedGameConfigsIDs(); len(nodes) > 0 && !mvu.mutation.GameConfigsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.GameConfigsTable,
			Columns: []string{mathversion.GameConfigsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(gameconfig.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvu.mutation.GameConfigsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.GameConfigsTable,
			Columns: []string{mathversion.GameConfigsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(gameconfig.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, mvu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{mathversion.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	mvu.mutation.done = true
	return n, nil
}

// MathVersionUpdateOne is the builder for updating a single MathVersion entity.
type MathVersionUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *MathVersionMutation
}

// SetName sets the "name" field.
func (mvuo *MathVersionUpdateOne) SetName(s string) *MathVersionUpdateOne {
	mvuo.mutation.SetName(s)
	return mvuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableName(s *string) *MathVersionUpdateOne {
	if s != nil {
		mvuo.SetName(*s)
	}
	return mvuo
}

// SetVersion sets the "version" field.
func (mvuo *MathVersionUpdateOne) SetVersion(s string) *MathVersionUpdateOne {
	mvuo.mutation.SetVersion(s)
	return mvuo
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableVersion(s *string) *MathVersionUpdateOne {
	if s != nil {
		mvuo.SetVersion(*s)
	}
	return mvuo
}

// SetVolatility sets the "volatility" field.
func (mvuo *MathVersionUpdateOne) SetVolatility(i int) *MathVersionUpdateOne {
	mvuo.mutation.ResetVolatility()
	mvuo.mutation.SetVolatility(i)
	return mvuo
}

// SetNillableVolatility sets the "volatility" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableVolatility(i *int) *MathVersionUpdateOne {
	if i != nil {
		mvuo.SetVolatility(*i)
	}
	return mvuo
}

// AddVolatility adds i to the "volatility" field.
func (mvuo *MathVersionUpdateOne) AddVolatility(i int) *MathVersionUpdateOne {
	mvuo.mutation.AddVolatility(i)
	return mvuo
}

// ClearVolatility clears the value of the "volatility" field.
func (mvuo *MathVersionUpdateOne) ClearVolatility() *MathVersionUpdateOne {
	mvuo.mutation.ClearVolatility()
	return mvuo
}

// SetRtp sets the "rtp" field.
func (mvuo *MathVersionUpdateOne) SetRtp(i int) *MathVersionUpdateOne {
	mvuo.mutation.ResetRtp()
	mvuo.mutation.SetRtp(i)
	return mvuo
}

// SetNillableRtp sets the "rtp" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableRtp(i *int) *MathVersionUpdateOne {
	if i != nil {
		mvuo.SetRtp(*i)
	}
	return mvuo
}

// AddRtp adds i to the "rtp" field.
func (mvuo *MathVersionUpdateOne) AddRtp(i int) *MathVersionUpdateOne {
	mvuo.mutation.AddRtp(i)
	return mvuo
}

// ClearRtp clears the value of the "rtp" field.
func (mvuo *MathVersionUpdateOne) ClearRtp() *MathVersionUpdateOne {
	mvuo.mutation.ClearRtp()
	return mvuo
}

// SetMaxWin sets the "max_win" field.
func (mvuo *MathVersionUpdateOne) SetMaxWin(i int) *MathVersionUpdateOne {
	mvuo.mutation.ResetMaxWin()
	mvuo.mutation.SetMaxWin(i)
	return mvuo
}

// SetNillableMaxWin sets the "max_win" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableMaxWin(i *int) *MathVersionUpdateOne {
	if i != nil {
		mvuo.SetMaxWin(*i)
	}
	return mvuo
}

// AddMaxWin adds i to the "max_win" field.
func (mvuo *MathVersionUpdateOne) AddMaxWin(i int) *MathVersionUpdateOne {
	mvuo.mutation.AddMaxWin(i)
	return mvuo
}

// ClearMaxWin clears the value of the "max_win" field.
func (mvuo *MathVersionUpdateOne) ClearMaxWin() *MathVersionUpdateOne {
	mvuo.mutation.ClearMaxWin()
	return mvuo
}

// SetCanBuyBonus sets the "can_buy_bonus" field.
func (mvuo *MathVersionUpdateOne) SetCanBuyBonus(b bool) *MathVersionUpdateOne {
	mvuo.mutation.SetCanBuyBonus(b)
	return mvuo
}

// SetNillableCanBuyBonus sets the "can_buy_bonus" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableCanBuyBonus(b *bool) *MathVersionUpdateOne {
	if b != nil {
		mvuo.SetCanBuyBonus(*b)
	}
	return mvuo
}

// ClearCanBuyBonus clears the value of the "can_buy_bonus" field.
func (mvuo *MathVersionUpdateOne) ClearCanBuyBonus() *MathVersionUpdateOne {
	mvuo.mutation.ClearCanBuyBonus()
	return mvuo
}

// SetURLReleaseNote sets the "url_release_note" field.
func (mvuo *MathVersionUpdateOne) SetURLReleaseNote(s string) *MathVersionUpdateOne {
	mvuo.mutation.SetURLReleaseNote(s)
	return mvuo
}

// SetNillableURLReleaseNote sets the "url_release_note" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableURLReleaseNote(s *string) *MathVersionUpdateOne {
	if s != nil {
		mvuo.SetURLReleaseNote(*s)
	}
	return mvuo
}

// ClearURLReleaseNote clears the value of the "url_release_note" field.
func (mvuo *MathVersionUpdateOne) ClearURLReleaseNote() *MathVersionUpdateOne {
	mvuo.mutation.ClearURLReleaseNote()
	return mvuo
}

// SetDeprecated sets the "deprecated" field.
func (mvuo *MathVersionUpdateOne) SetDeprecated(b bool) *MathVersionUpdateOne {
	mvuo.mutation.SetDeprecated(b)
	return mvuo
}

// SetNillableDeprecated sets the "deprecated" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableDeprecated(b *bool) *MathVersionUpdateOne {
	if b != nil {
		mvuo.SetDeprecated(*b)
	}
	return mvuo
}

// SetCanAnteBet sets the "can_ante_bet" field.
func (mvuo *MathVersionUpdateOne) SetCanAnteBet(b bool) *MathVersionUpdateOne {
	mvuo.mutation.SetCanAnteBet(b)
	return mvuo
}

// SetNillableCanAnteBet sets the "can_ante_bet" field if the given value is not nil.
func (mvuo *MathVersionUpdateOne) SetNillableCanAnteBet(b *bool) *MathVersionUpdateOne {
	if b != nil {
		mvuo.SetCanAnteBet(*b)
	}
	return mvuo
}

// ClearCanAnteBet clears the value of the "can_ante_bet" field.
func (mvuo *MathVersionUpdateOne) ClearCanAnteBet() *MathVersionUpdateOne {
	mvuo.mutation.ClearCanAnteBet()
	return mvuo
}

// AddSessionIDs adds the "sessions" edge to the Session entity by IDs.
func (mvuo *MathVersionUpdateOne) AddSessionIDs(ids ...int) *MathVersionUpdateOne {
	mvuo.mutation.AddSessionIDs(ids...)
	return mvuo
}

// AddSessions adds the "sessions" edges to the Session entity.
func (mvuo *MathVersionUpdateOne) AddSessions(s ...*Session) *MathVersionUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return mvuo.AddSessionIDs(ids...)
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by IDs.
func (mvuo *MathVersionUpdateOne) AddGameConfigIDs(ids ...int) *MathVersionUpdateOne {
	mvuo.mutation.AddGameConfigIDs(ids...)
	return mvuo
}

// AddGameConfigs adds the "game_configs" edges to the GameConfig entity.
func (mvuo *MathVersionUpdateOne) AddGameConfigs(g ...*GameConfig) *MathVersionUpdateOne {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return mvuo.AddGameConfigIDs(ids...)
}

// Mutation returns the MathVersionMutation object of the builder.
func (mvuo *MathVersionUpdateOne) Mutation() *MathVersionMutation {
	return mvuo.mutation
}

// ClearSessions clears all "sessions" edges to the Session entity.
func (mvuo *MathVersionUpdateOne) ClearSessions() *MathVersionUpdateOne {
	mvuo.mutation.ClearSessions()
	return mvuo
}

// RemoveSessionIDs removes the "sessions" edge to Session entities by IDs.
func (mvuo *MathVersionUpdateOne) RemoveSessionIDs(ids ...int) *MathVersionUpdateOne {
	mvuo.mutation.RemoveSessionIDs(ids...)
	return mvuo
}

// RemoveSessions removes "sessions" edges to Session entities.
func (mvuo *MathVersionUpdateOne) RemoveSessions(s ...*Session) *MathVersionUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return mvuo.RemoveSessionIDs(ids...)
}

// ClearGameConfigs clears all "game_configs" edges to the GameConfig entity.
func (mvuo *MathVersionUpdateOne) ClearGameConfigs() *MathVersionUpdateOne {
	mvuo.mutation.ClearGameConfigs()
	return mvuo
}

// RemoveGameConfigIDs removes the "game_configs" edge to GameConfig entities by IDs.
func (mvuo *MathVersionUpdateOne) RemoveGameConfigIDs(ids ...int) *MathVersionUpdateOne {
	mvuo.mutation.RemoveGameConfigIDs(ids...)
	return mvuo
}

// RemoveGameConfigs removes "game_configs" edges to GameConfig entities.
func (mvuo *MathVersionUpdateOne) RemoveGameConfigs(g ...*GameConfig) *MathVersionUpdateOne {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return mvuo.RemoveGameConfigIDs(ids...)
}

// Where appends a list predicates to the MathVersionUpdate builder.
func (mvuo *MathVersionUpdateOne) Where(ps ...predicate.MathVersion) *MathVersionUpdateOne {
	mvuo.mutation.Where(ps...)
	return mvuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (mvuo *MathVersionUpdateOne) Select(field string, fields ...string) *MathVersionUpdateOne {
	mvuo.fields = append([]string{field}, fields...)
	return mvuo
}

// Save executes the query and returns the updated MathVersion entity.
func (mvuo *MathVersionUpdateOne) Save(ctx context.Context) (*MathVersion, error) {
	return withHooks(ctx, mvuo.sqlSave, mvuo.mutation, mvuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (mvuo *MathVersionUpdateOne) SaveX(ctx context.Context) *MathVersion {
	node, err := mvuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (mvuo *MathVersionUpdateOne) Exec(ctx context.Context) error {
	_, err := mvuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (mvuo *MathVersionUpdateOne) ExecX(ctx context.Context) {
	if err := mvuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (mvuo *MathVersionUpdateOne) sqlSave(ctx context.Context) (_node *MathVersion, err error) {
	_spec := sqlgraph.NewUpdateSpec(mathversion.Table, mathversion.Columns, sqlgraph.NewFieldSpec(mathversion.FieldID, field.TypeInt))
	id, ok := mvuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "MathVersion.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := mvuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, mathversion.FieldID)
		for _, f := range fields {
			if !mathversion.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != mathversion.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := mvuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := mvuo.mutation.Name(); ok {
		_spec.SetField(mathversion.FieldName, field.TypeString, value)
	}
	if value, ok := mvuo.mutation.Version(); ok {
		_spec.SetField(mathversion.FieldVersion, field.TypeString, value)
	}
	if value, ok := mvuo.mutation.Volatility(); ok {
		_spec.SetField(mathversion.FieldVolatility, field.TypeInt, value)
	}
	if value, ok := mvuo.mutation.AddedVolatility(); ok {
		_spec.AddField(mathversion.FieldVolatility, field.TypeInt, value)
	}
	if mvuo.mutation.VolatilityCleared() {
		_spec.ClearField(mathversion.FieldVolatility, field.TypeInt)
	}
	if value, ok := mvuo.mutation.Rtp(); ok {
		_spec.SetField(mathversion.FieldRtp, field.TypeInt, value)
	}
	if value, ok := mvuo.mutation.AddedRtp(); ok {
		_spec.AddField(mathversion.FieldRtp, field.TypeInt, value)
	}
	if mvuo.mutation.RtpCleared() {
		_spec.ClearField(mathversion.FieldRtp, field.TypeInt)
	}
	if value, ok := mvuo.mutation.MaxWin(); ok {
		_spec.SetField(mathversion.FieldMaxWin, field.TypeInt, value)
	}
	if value, ok := mvuo.mutation.AddedMaxWin(); ok {
		_spec.AddField(mathversion.FieldMaxWin, field.TypeInt, value)
	}
	if mvuo.mutation.MaxWinCleared() {
		_spec.ClearField(mathversion.FieldMaxWin, field.TypeInt)
	}
	if value, ok := mvuo.mutation.CanBuyBonus(); ok {
		_spec.SetField(mathversion.FieldCanBuyBonus, field.TypeBool, value)
	}
	if mvuo.mutation.CanBuyBonusCleared() {
		_spec.ClearField(mathversion.FieldCanBuyBonus, field.TypeBool)
	}
	if value, ok := mvuo.mutation.URLReleaseNote(); ok {
		_spec.SetField(mathversion.FieldURLReleaseNote, field.TypeString, value)
	}
	if mvuo.mutation.URLReleaseNoteCleared() {
		_spec.ClearField(mathversion.FieldURLReleaseNote, field.TypeString)
	}
	if value, ok := mvuo.mutation.Deprecated(); ok {
		_spec.SetField(mathversion.FieldDeprecated, field.TypeBool, value)
	}
	if value, ok := mvuo.mutation.CanAnteBet(); ok {
		_spec.SetField(mathversion.FieldCanAnteBet, field.TypeBool, value)
	}
	if mvuo.mutation.CanAnteBetCleared() {
		_spec.ClearField(mathversion.FieldCanAnteBet, field.TypeBool)
	}
	if mvuo.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.SessionsTable,
			Columns: []string{mathversion.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvuo.mutation.RemovedSessionsIDs(); len(nodes) > 0 && !mvuo.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.SessionsTable,
			Columns: []string{mathversion.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvuo.mutation.SessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.SessionsTable,
			Columns: []string{mathversion.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if mvuo.mutation.GameConfigsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.GameConfigsTable,
			Columns: []string{mathversion.GameConfigsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(gameconfig.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvuo.mutation.RemovedGameConfigsIDs(); len(nodes) > 0 && !mvuo.mutation.GameConfigsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.GameConfigsTable,
			Columns: []string{mathversion.GameConfigsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(gameconfig.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mvuo.mutation.GameConfigsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   mathversion.GameConfigsTable,
			Columns: []string{mathversion.GameConfigsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(gameconfig.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &MathVersion{config: mvuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, mvuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{mathversion.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	mvuo.mutation.done = true
	return _node, nil
}
