// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/Lavizord/checkers-server/postgrescli/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Lavizord/checkers-server/postgrescli/ent/currency"
	"github.com/Lavizord/checkers-server/postgrescli/ent/currencyversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/feature"
	"github.com/Lavizord/checkers-server/postgrescli/ent/game"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gameconfig"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gamefeature"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gametype"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gameversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/mathversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/operator"
	"github.com/Lavizord/checkers-server/postgrescli/ent/platform"
	"github.com/Lavizord/checkers-server/postgrescli/ent/serie"
	"github.com/Lavizord/checkers-server/postgrescli/ent/seriefeature"
	"github.com/Lavizord/checkers-server/postgrescli/ent/session"
	"github.com/Lavizord/checkers-server/postgrescli/ent/studio"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Currency is the client for interacting with the Currency builders.
	Currency *CurrencyClient
	// CurrencyVersion is the client for interacting with the CurrencyVersion builders.
	CurrencyVersion *CurrencyVersionClient
	// Feature is the client for interacting with the Feature builders.
	Feature *FeatureClient
	// Game is the client for interacting with the Game builders.
	Game *GameClient
	// GameConfig is the client for interacting with the GameConfig builders.
	GameConfig *GameConfigClient
	// GameFeature is the client for interacting with the GameFeature builders.
	GameFeature *GameFeatureClient
	// GameType is the client for interacting with the GameType builders.
	GameType *GameTypeClient
	// GameVersion is the client for interacting with the GameVersion builders.
	GameVersion *GameVersionClient
	// MathVersion is the client for interacting with the MathVersion builders.
	MathVersion *MathVersionClient
	// Operator is the client for interacting with the Operator builders.
	Operator *OperatorClient
	// Platform is the client for interacting with the Platform builders.
	Platform *PlatformClient
	// Serie is the client for interacting with the Serie builders.
	Serie *SerieClient
	// SerieFeature is the client for interacting with the SerieFeature builders.
	SerieFeature *SerieFeatureClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Studio is the client for interacting with the Studio builders.
	Studio *StudioClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Currency = NewCurrencyClient(c.config)
	c.CurrencyVersion = NewCurrencyVersionClient(c.config)
	c.Feature = NewFeatureClient(c.config)
	c.Game = NewGameClient(c.config)
	c.GameConfig = NewGameConfigClient(c.config)
	c.GameFeature = NewGameFeatureClient(c.config)
	c.GameType = NewGameTypeClient(c.config)
	c.GameVersion = NewGameVersionClient(c.config)
	c.MathVersion = NewMathVersionClient(c.config)
	c.Operator = NewOperatorClient(c.config)
	c.Platform = NewPlatformClient(c.config)
	c.Serie = NewSerieClient(c.config)
	c.SerieFeature = NewSerieFeatureClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Studio = NewStudioClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Currency:        NewCurrencyClient(cfg),
		CurrencyVersion: NewCurrencyVersionClient(cfg),
		Feature:         NewFeatureClient(cfg),
		Game:            NewGameClient(cfg),
		GameConfig:      NewGameConfigClient(cfg),
		GameFeature:     NewGameFeatureClient(cfg),
		GameType:        NewGameTypeClient(cfg),
		GameVersion:     NewGameVersionClient(cfg),
		MathVersion:     NewMathVersionClient(cfg),
		Operator:        NewOperatorClient(cfg),
		Platform:        NewPlatformClient(cfg),
		Serie:           NewSerieClient(cfg),
		SerieFeature:    NewSerieFeatureClient(cfg),
		Session:         NewSessionClient(cfg),
		Studio:          NewStudioClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Currency:        NewCurrencyClient(cfg),
		CurrencyVersion: NewCurrencyVersionClient(cfg),
		Feature:         NewFeatureClient(cfg),
		Game:            NewGameClient(cfg),
		GameConfig:      NewGameConfigClient(cfg),
		GameFeature:     NewGameFeatureClient(cfg),
		GameType:        NewGameTypeClient(cfg),
		GameVersion:     NewGameVersionClient(cfg),
		MathVersion:     NewMathVersionClient(cfg),
		Operator:        NewOperatorClient(cfg),
		Platform:        NewPlatformClient(cfg),
		Serie:           NewSerieClient(cfg),
		SerieFeature:    NewSerieFeatureClient(cfg),
		Session:         NewSessionClient(cfg),
		Studio:          NewStudioClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Currency.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Currency, c.CurrencyVersion, c.Feature, c.Game, c.GameConfig, c.GameFeature,
		c.GameType, c.GameVersion, c.MathVersion, c.Operator, c.Platform, c.Serie,
		c.SerieFeature, c.Session, c.Studio,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Currency, c.CurrencyVersion, c.Feature, c.Game, c.GameConfig, c.GameFeature,
		c.GameType, c.GameVersion, c.MathVersion, c.Operator, c.Platform, c.Serie,
		c.SerieFeature, c.Session, c.Studio,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CurrencyMutation:
		return c.Currency.mutate(ctx, m)
	case *CurrencyVersionMutation:
		return c.CurrencyVersion.mutate(ctx, m)
	case *FeatureMutation:
		return c.Feature.mutate(ctx, m)
	case *GameMutation:
		return c.Game.mutate(ctx, m)
	case *GameConfigMutation:
		return c.GameConfig.mutate(ctx, m)
	case *GameFeatureMutation:
		return c.GameFeature.mutate(ctx, m)
	case *GameTypeMutation:
		return c.GameType.mutate(ctx, m)
	case *GameVersionMutation:
		return c.GameVersion.mutate(ctx, m)
	case *MathVersionMutation:
		return c.MathVersion.mutate(ctx, m)
	case *OperatorMutation:
		return c.Operator.mutate(ctx, m)
	case *PlatformMutation:
		return c.Platform.mutate(ctx, m)
	case *SerieMutation:
		return c.Serie.mutate(ctx, m)
	case *SerieFeatureMutation:
		return c.SerieFeature.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *StudioMutation:
		return c.Studio.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CurrencyClient is a client for the Currency schema.
type CurrencyClient struct {
	config
}

// NewCurrencyClient returns a client for the Currency from the given config.
func NewCurrencyClient(c config) *CurrencyClient {
	return &CurrencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `currency.Hooks(f(g(h())))`.
func (c *CurrencyClient) Use(hooks ...Hook) {
	c.hooks.Currency = append(c.hooks.Currency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `currency.Intercept(f(g(h())))`.
func (c *CurrencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Currency = append(c.inters.Currency, interceptors...)
}

// Create returns a builder for creating a Currency entity.
func (c *CurrencyClient) Create() *CurrencyCreate {
	mutation := newCurrencyMutation(c.config, OpCreate)
	return &CurrencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Currency entities.
func (c *CurrencyClient) CreateBulk(builders ...*CurrencyCreate) *CurrencyCreateBulk {
	return &CurrencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CurrencyClient) MapCreateBulk(slice any, setFunc func(*CurrencyCreate, int)) *CurrencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CurrencyCreateBulk{err: fmt.Errorf("calling to CurrencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CurrencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CurrencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Currency.
func (c *CurrencyClient) Update() *CurrencyUpdate {
	mutation := newCurrencyMutation(c.config, OpUpdate)
	return &CurrencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CurrencyClient) UpdateOne(cu *Currency) *CurrencyUpdateOne {
	mutation := newCurrencyMutation(c.config, OpUpdateOne, withCurrency(cu))
	return &CurrencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CurrencyClient) UpdateOneID(id int) *CurrencyUpdateOne {
	mutation := newCurrencyMutation(c.config, OpUpdateOne, withCurrencyID(id))
	return &CurrencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Currency.
func (c *CurrencyClient) Delete() *CurrencyDelete {
	mutation := newCurrencyMutation(c.config, OpDelete)
	return &CurrencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CurrencyClient) DeleteOne(cu *Currency) *CurrencyDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CurrencyClient) DeleteOneID(id int) *CurrencyDeleteOne {
	builder := c.Delete().Where(currency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CurrencyDeleteOne{builder}
}

// Query returns a query builder for Currency.
func (c *CurrencyClient) Query() *CurrencyQuery {
	return &CurrencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCurrency},
		inters: c.Interceptors(),
	}
}

// Get returns a Currency entity by its id.
func (c *CurrencyClient) Get(ctx context.Context, id int) (*Currency, error) {
	return c.Query().Where(currency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CurrencyClient) GetX(ctx context.Context, id int) *Currency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCurrencyVersions queries the currency_versions edge of a Currency.
func (c *CurrencyClient) QueryCurrencyVersions(cu *Currency) *CurrencyVersionQuery {
	query := (&CurrencyVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(currency.Table, currency.FieldID, id),
			sqlgraph.To(currencyversion.Table, currencyversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, currency.CurrencyVersionsTable, currency.CurrencyVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CurrencyClient) Hooks() []Hook {
	return c.hooks.Currency
}

// Interceptors returns the client interceptors.
func (c *CurrencyClient) Interceptors() []Interceptor {
	return c.inters.Currency
}

func (c *CurrencyClient) mutate(ctx context.Context, m *CurrencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CurrencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CurrencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CurrencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CurrencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Currency mutation op: %q", m.Op())
	}
}

// CurrencyVersionClient is a client for the CurrencyVersion schema.
type CurrencyVersionClient struct {
	config
}

// NewCurrencyVersionClient returns a client for the CurrencyVersion from the given config.
func NewCurrencyVersionClient(c config) *CurrencyVersionClient {
	return &CurrencyVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `currencyversion.Hooks(f(g(h())))`.
func (c *CurrencyVersionClient) Use(hooks ...Hook) {
	c.hooks.CurrencyVersion = append(c.hooks.CurrencyVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `currencyversion.Intercept(f(g(h())))`.
func (c *CurrencyVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CurrencyVersion = append(c.inters.CurrencyVersion, interceptors...)
}

// Create returns a builder for creating a CurrencyVersion entity.
func (c *CurrencyVersionClient) Create() *CurrencyVersionCreate {
	mutation := newCurrencyVersionMutation(c.config, OpCreate)
	return &CurrencyVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CurrencyVersion entities.
func (c *CurrencyVersionClient) CreateBulk(builders ...*CurrencyVersionCreate) *CurrencyVersionCreateBulk {
	return &CurrencyVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CurrencyVersionClient) MapCreateBulk(slice any, setFunc func(*CurrencyVersionCreate, int)) *CurrencyVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CurrencyVersionCreateBulk{err: fmt.Errorf("calling to CurrencyVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CurrencyVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CurrencyVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CurrencyVersion.
func (c *CurrencyVersionClient) Update() *CurrencyVersionUpdate {
	mutation := newCurrencyVersionMutation(c.config, OpUpdate)
	return &CurrencyVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CurrencyVersionClient) UpdateOne(cv *CurrencyVersion) *CurrencyVersionUpdateOne {
	mutation := newCurrencyVersionMutation(c.config, OpUpdateOne, withCurrencyVersion(cv))
	return &CurrencyVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CurrencyVersionClient) UpdateOneID(id int) *CurrencyVersionUpdateOne {
	mutation := newCurrencyVersionMutation(c.config, OpUpdateOne, withCurrencyVersionID(id))
	return &CurrencyVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CurrencyVersion.
func (c *CurrencyVersionClient) Delete() *CurrencyVersionDelete {
	mutation := newCurrencyVersionMutation(c.config, OpDelete)
	return &CurrencyVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CurrencyVersionClient) DeleteOne(cv *CurrencyVersion) *CurrencyVersionDeleteOne {
	return c.DeleteOneID(cv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CurrencyVersionClient) DeleteOneID(id int) *CurrencyVersionDeleteOne {
	builder := c.Delete().Where(currencyversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CurrencyVersionDeleteOne{builder}
}

// Query returns a query builder for CurrencyVersion.
func (c *CurrencyVersionClient) Query() *CurrencyVersionQuery {
	return &CurrencyVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCurrencyVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a CurrencyVersion entity by its id.
func (c *CurrencyVersionClient) Get(ctx context.Context, id int) (*CurrencyVersion, error) {
	return c.Query().Where(currencyversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CurrencyVersionClient) GetX(ctx context.Context, id int) *CurrencyVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCurrency queries the Currency edge of a CurrencyVersion.
func (c *CurrencyVersionClient) QueryCurrency(cv *CurrencyVersion) *CurrencyQuery {
	query := (&CurrencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(currencyversion.Table, currencyversion.FieldID, id),
			sqlgraph.To(currency.Table, currency.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, currencyversion.CurrencyTable, currencyversion.CurrencyColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameTypes queries the game_types edge of a CurrencyVersion.
func (c *CurrencyVersionClient) QueryGameTypes(cv *CurrencyVersion) *GameTypeQuery {
	query := (&GameTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(currencyversion.Table, currencyversion.FieldID, id),
			sqlgraph.To(gametype.Table, gametype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, currencyversion.GameTypesTable, currencyversion.GameTypesColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a CurrencyVersion.
func (c *CurrencyVersionClient) QuerySessions(cv *CurrencyVersion) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(currencyversion.Table, currencyversion.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, currencyversion.SessionsTable, currencyversion.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameConfigs queries the game_configs edge of a CurrencyVersion.
func (c *CurrencyVersionClient) QueryGameConfigs(cv *CurrencyVersion) *GameConfigQuery {
	query := (&GameConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(currencyversion.Table, currencyversion.FieldID, id),
			sqlgraph.To(gameconfig.Table, gameconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, currencyversion.GameConfigsTable, currencyversion.GameConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CurrencyVersionClient) Hooks() []Hook {
	return c.hooks.CurrencyVersion
}

// Interceptors returns the client interceptors.
func (c *CurrencyVersionClient) Interceptors() []Interceptor {
	return c.inters.CurrencyVersion
}

func (c *CurrencyVersionClient) mutate(ctx context.Context, m *CurrencyVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CurrencyVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CurrencyVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CurrencyVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CurrencyVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CurrencyVersion mutation op: %q", m.Op())
	}
}

// FeatureClient is a client for the Feature schema.
type FeatureClient struct {
	config
}

// NewFeatureClient returns a client for the Feature from the given config.
func NewFeatureClient(c config) *FeatureClient {
	return &FeatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `feature.Hooks(f(g(h())))`.
func (c *FeatureClient) Use(hooks ...Hook) {
	c.hooks.Feature = append(c.hooks.Feature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `feature.Intercept(f(g(h())))`.
func (c *FeatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Feature = append(c.inters.Feature, interceptors...)
}

// Create returns a builder for creating a Feature entity.
func (c *FeatureClient) Create() *FeatureCreate {
	mutation := newFeatureMutation(c.config, OpCreate)
	return &FeatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Feature entities.
func (c *FeatureClient) CreateBulk(builders ...*FeatureCreate) *FeatureCreateBulk {
	return &FeatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeatureClient) MapCreateBulk(slice any, setFunc func(*FeatureCreate, int)) *FeatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeatureCreateBulk{err: fmt.Errorf("calling to FeatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Feature.
func (c *FeatureClient) Update() *FeatureUpdate {
	mutation := newFeatureMutation(c.config, OpUpdate)
	return &FeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeatureClient) UpdateOne(f *Feature) *FeatureUpdateOne {
	mutation := newFeatureMutation(c.config, OpUpdateOne, withFeature(f))
	return &FeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeatureClient) UpdateOneID(id int) *FeatureUpdateOne {
	mutation := newFeatureMutation(c.config, OpUpdateOne, withFeatureID(id))
	return &FeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Feature.
func (c *FeatureClient) Delete() *FeatureDelete {
	mutation := newFeatureMutation(c.config, OpDelete)
	return &FeatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeatureClient) DeleteOne(f *Feature) *FeatureDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeatureClient) DeleteOneID(id int) *FeatureDeleteOne {
	builder := c.Delete().Where(feature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeatureDeleteOne{builder}
}

// Query returns a query builder for Feature.
func (c *FeatureClient) Query() *FeatureQuery {
	return &FeatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeature},
		inters: c.Interceptors(),
	}
}

// Get returns a Feature entity by its id.
func (c *FeatureClient) Get(ctx context.Context, id int) (*Feature, error) {
	return c.Query().Where(feature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeatureClient) GetX(ctx context.Context, id int) *Feature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGameFeatures queries the game_features edge of a Feature.
func (c *FeatureClient) QueryGameFeatures(f *Feature) *GameFeatureQuery {
	query := (&GameFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feature.Table, feature.FieldID, id),
			sqlgraph.To(gamefeature.Table, gamefeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, feature.GameFeaturesTable, feature.GameFeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySerieFeatures queries the serie_features edge of a Feature.
func (c *FeatureClient) QuerySerieFeatures(f *Feature) *SerieFeatureQuery {
	query := (&SerieFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feature.Table, feature.FieldID, id),
			sqlgraph.To(seriefeature.Table, seriefeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, feature.SerieFeaturesTable, feature.SerieFeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeatureClient) Hooks() []Hook {
	return c.hooks.Feature
}

// Interceptors returns the client interceptors.
func (c *FeatureClient) Interceptors() []Interceptor {
	return c.inters.Feature
}

func (c *FeatureClient) mutate(ctx context.Context, m *FeatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Feature mutation op: %q", m.Op())
	}
}

// GameClient is a client for the Game schema.
type GameClient struct {
	config
}

// NewGameClient returns a client for the Game from the given config.
func NewGameClient(c config) *GameClient {
	return &GameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `game.Hooks(f(g(h())))`.
func (c *GameClient) Use(hooks ...Hook) {
	c.hooks.Game = append(c.hooks.Game, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `game.Intercept(f(g(h())))`.
func (c *GameClient) Intercept(interceptors ...Interceptor) {
	c.inters.Game = append(c.inters.Game, interceptors...)
}

// Create returns a builder for creating a Game entity.
func (c *GameClient) Create() *GameCreate {
	mutation := newGameMutation(c.config, OpCreate)
	return &GameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Game entities.
func (c *GameClient) CreateBulk(builders ...*GameCreate) *GameCreateBulk {
	return &GameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameClient) MapCreateBulk(slice any, setFunc func(*GameCreate, int)) *GameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameCreateBulk{err: fmt.Errorf("calling to GameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Game.
func (c *GameClient) Update() *GameUpdate {
	mutation := newGameMutation(c.config, OpUpdate)
	return &GameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameClient) UpdateOne(ga *Game) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGame(ga))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameClient) UpdateOneID(id int) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGameID(id))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Game.
func (c *GameClient) Delete() *GameDelete {
	mutation := newGameMutation(c.config, OpDelete)
	return &GameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameClient) DeleteOne(ga *Game) *GameDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameClient) DeleteOneID(id int) *GameDeleteOne {
	builder := c.Delete().Where(game.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameDeleteOne{builder}
}

// Query returns a query builder for Game.
func (c *GameClient) Query() *GameQuery {
	return &GameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGame},
		inters: c.Interceptors(),
	}
}

// Get returns a Game entity by its id.
func (c *GameClient) Get(ctx context.Context, id int) (*Game, error) {
	return c.Query().Where(game.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameClient) GetX(ctx context.Context, id int) *Game {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStudio queries the studio edge of a Game.
func (c *GameClient) QueryStudio(ga *Game) *StudioQuery {
	query := (&StudioClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(studio.Table, studio.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, game.StudioTable, game.StudioColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameType queries the game_type edge of a Game.
func (c *GameClient) QueryGameType(ga *Game) *GameTypeQuery {
	query := (&GameTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gametype.Table, gametype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, game.GameTypeTable, game.GameTypeColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySerie queries the serie edge of a Game.
func (c *GameClient) QuerySerie(ga *Game) *SerieQuery {
	query := (&SerieClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(serie.Table, serie.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, game.SerieTable, game.SerieColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameFeatures queries the game_features edge of a Game.
func (c *GameClient) QueryGameFeatures(ga *Game) *GameFeatureQuery {
	query := (&GameFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gamefeature.Table, gamefeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.GameFeaturesTable, game.GameFeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameVersions queries the game_versions edge of a Game.
func (c *GameClient) QueryGameVersions(ga *Game) *GameVersionQuery {
	query := (&GameVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gameversion.Table, gameversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.GameVersionsTable, game.GameVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameConfigs queries the game_configs edge of a Game.
func (c *GameClient) QueryGameConfigs(ga *Game) *GameConfigQuery {
	query := (&GameConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gameconfig.Table, gameconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.GameConfigsTable, game.GameConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a Game.
func (c *GameClient) QuerySessions(ga *Game) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.SessionsTable, game.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameClient) Hooks() []Hook {
	return c.hooks.Game
}

// Interceptors returns the client interceptors.
func (c *GameClient) Interceptors() []Interceptor {
	return c.inters.Game
}

func (c *GameClient) mutate(ctx context.Context, m *GameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Game mutation op: %q", m.Op())
	}
}

// GameConfigClient is a client for the GameConfig schema.
type GameConfigClient struct {
	config
}

// NewGameConfigClient returns a client for the GameConfig from the given config.
func NewGameConfigClient(c config) *GameConfigClient {
	return &GameConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameconfig.Hooks(f(g(h())))`.
func (c *GameConfigClient) Use(hooks ...Hook) {
	c.hooks.GameConfig = append(c.hooks.GameConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gameconfig.Intercept(f(g(h())))`.
func (c *GameConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.GameConfig = append(c.inters.GameConfig, interceptors...)
}

// Create returns a builder for creating a GameConfig entity.
func (c *GameConfigClient) Create() *GameConfigCreate {
	mutation := newGameConfigMutation(c.config, OpCreate)
	return &GameConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GameConfig entities.
func (c *GameConfigClient) CreateBulk(builders ...*GameConfigCreate) *GameConfigCreateBulk {
	return &GameConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameConfigClient) MapCreateBulk(slice any, setFunc func(*GameConfigCreate, int)) *GameConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameConfigCreateBulk{err: fmt.Errorf("calling to GameConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GameConfig.
func (c *GameConfigClient) Update() *GameConfigUpdate {
	mutation := newGameConfigMutation(c.config, OpUpdate)
	return &GameConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameConfigClient) UpdateOne(gc *GameConfig) *GameConfigUpdateOne {
	mutation := newGameConfigMutation(c.config, OpUpdateOne, withGameConfig(gc))
	return &GameConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameConfigClient) UpdateOneID(id int) *GameConfigUpdateOne {
	mutation := newGameConfigMutation(c.config, OpUpdateOne, withGameConfigID(id))
	return &GameConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GameConfig.
func (c *GameConfigClient) Delete() *GameConfigDelete {
	mutation := newGameConfigMutation(c.config, OpDelete)
	return &GameConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameConfigClient) DeleteOne(gc *GameConfig) *GameConfigDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameConfigClient) DeleteOneID(id int) *GameConfigDeleteOne {
	builder := c.Delete().Where(gameconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameConfigDeleteOne{builder}
}

// Query returns a query builder for GameConfig.
func (c *GameConfigClient) Query() *GameConfigQuery {
	return &GameConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGameConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a GameConfig entity by its id.
func (c *GameConfigClient) Get(ctx context.Context, id int) (*GameConfig, error) {
	return c.Query().Where(gameconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameConfigClient) GetX(ctx context.Context, id int) *GameConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMathVersions queries the math_versions edge of a GameConfig.
func (c *GameConfigClient) QueryMathVersions(gc *GameConfig) *MathVersionQuery {
	query := (&MathVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameconfig.Table, gameconfig.FieldID, id),
			sqlgraph.To(mathversion.Table, mathversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameconfig.MathVersionsTable, gameconfig.MathVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameVersions queries the game_versions edge of a GameConfig.
func (c *GameConfigClient) QueryGameVersions(gc *GameConfig) *GameVersionQuery {
	query := (&GameVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameconfig.Table, gameconfig.FieldID, id),
			sqlgraph.To(gameversion.Table, gameversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameconfig.GameVersionsTable, gameconfig.GameVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGames queries the games edge of a GameConfig.
func (c *GameConfigClient) QueryGames(gc *GameConfig) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameconfig.Table, gameconfig.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameconfig.GamesTable, gameconfig.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOperator queries the Operator edge of a GameConfig.
func (c *GameConfigClient) QueryOperator(gc *GameConfig) *OperatorQuery {
	query := (&OperatorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameconfig.Table, gameconfig.FieldID, id),
			sqlgraph.To(operator.Table, operator.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameconfig.OperatorTable, gameconfig.OperatorColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCurrencyVersions queries the currency_versions edge of a GameConfig.
func (c *GameConfigClient) QueryCurrencyVersions(gc *GameConfig) *CurrencyVersionQuery {
	query := (&CurrencyVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameconfig.Table, gameconfig.FieldID, id),
			sqlgraph.To(currencyversion.Table, currencyversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameconfig.CurrencyVersionsTable, gameconfig.CurrencyVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameConfigClient) Hooks() []Hook {
	return c.hooks.GameConfig
}

// Interceptors returns the client interceptors.
func (c *GameConfigClient) Interceptors() []Interceptor {
	return c.inters.GameConfig
}

func (c *GameConfigClient) mutate(ctx context.Context, m *GameConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GameConfig mutation op: %q", m.Op())
	}
}

// GameFeatureClient is a client for the GameFeature schema.
type GameFeatureClient struct {
	config
}

// NewGameFeatureClient returns a client for the GameFeature from the given config.
func NewGameFeatureClient(c config) *GameFeatureClient {
	return &GameFeatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gamefeature.Hooks(f(g(h())))`.
func (c *GameFeatureClient) Use(hooks ...Hook) {
	c.hooks.GameFeature = append(c.hooks.GameFeature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gamefeature.Intercept(f(g(h())))`.
func (c *GameFeatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.GameFeature = append(c.inters.GameFeature, interceptors...)
}

// Create returns a builder for creating a GameFeature entity.
func (c *GameFeatureClient) Create() *GameFeatureCreate {
	mutation := newGameFeatureMutation(c.config, OpCreate)
	return &GameFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GameFeature entities.
func (c *GameFeatureClient) CreateBulk(builders ...*GameFeatureCreate) *GameFeatureCreateBulk {
	return &GameFeatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameFeatureClient) MapCreateBulk(slice any, setFunc func(*GameFeatureCreate, int)) *GameFeatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameFeatureCreateBulk{err: fmt.Errorf("calling to GameFeatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameFeatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameFeatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GameFeature.
func (c *GameFeatureClient) Update() *GameFeatureUpdate {
	mutation := newGameFeatureMutation(c.config, OpUpdate)
	return &GameFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameFeatureClient) UpdateOne(gf *GameFeature) *GameFeatureUpdateOne {
	mutation := newGameFeatureMutation(c.config, OpUpdateOne, withGameFeature(gf))
	return &GameFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameFeatureClient) UpdateOneID(id int) *GameFeatureUpdateOne {
	mutation := newGameFeatureMutation(c.config, OpUpdateOne, withGameFeatureID(id))
	return &GameFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GameFeature.
func (c *GameFeatureClient) Delete() *GameFeatureDelete {
	mutation := newGameFeatureMutation(c.config, OpDelete)
	return &GameFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameFeatureClient) DeleteOne(gf *GameFeature) *GameFeatureDeleteOne {
	return c.DeleteOneID(gf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameFeatureClient) DeleteOneID(id int) *GameFeatureDeleteOne {
	builder := c.Delete().Where(gamefeature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameFeatureDeleteOne{builder}
}

// Query returns a query builder for GameFeature.
func (c *GameFeatureClient) Query() *GameFeatureQuery {
	return &GameFeatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGameFeature},
		inters: c.Interceptors(),
	}
}

// Get returns a GameFeature entity by its id.
func (c *GameFeatureClient) Get(ctx context.Context, id int) (*GameFeature, error) {
	return c.Query().Where(gamefeature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameFeatureClient) GetX(ctx context.Context, id int) *GameFeature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFeatures queries the features edge of a GameFeature.
func (c *GameFeatureClient) QueryFeatures(gf *GameFeature) *FeatureQuery {
	query := (&FeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gamefeature.Table, gamefeature.FieldID, id),
			sqlgraph.To(feature.Table, feature.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gamefeature.FeaturesTable, gamefeature.FeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(gf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGames queries the games edge of a GameFeature.
func (c *GameFeatureClient) QueryGames(gf *GameFeature) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gamefeature.Table, gamefeature.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gamefeature.GamesTable, gamefeature.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(gf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameFeatureClient) Hooks() []Hook {
	return c.hooks.GameFeature
}

// Interceptors returns the client interceptors.
func (c *GameFeatureClient) Interceptors() []Interceptor {
	return c.inters.GameFeature
}

func (c *GameFeatureClient) mutate(ctx context.Context, m *GameFeatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GameFeature mutation op: %q", m.Op())
	}
}

// GameTypeClient is a client for the GameType schema.
type GameTypeClient struct {
	config
}

// NewGameTypeClient returns a client for the GameType from the given config.
func NewGameTypeClient(c config) *GameTypeClient {
	return &GameTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gametype.Hooks(f(g(h())))`.
func (c *GameTypeClient) Use(hooks ...Hook) {
	c.hooks.GameType = append(c.hooks.GameType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gametype.Intercept(f(g(h())))`.
func (c *GameTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.GameType = append(c.inters.GameType, interceptors...)
}

// Create returns a builder for creating a GameType entity.
func (c *GameTypeClient) Create() *GameTypeCreate {
	mutation := newGameTypeMutation(c.config, OpCreate)
	return &GameTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GameType entities.
func (c *GameTypeClient) CreateBulk(builders ...*GameTypeCreate) *GameTypeCreateBulk {
	return &GameTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameTypeClient) MapCreateBulk(slice any, setFunc func(*GameTypeCreate, int)) *GameTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameTypeCreateBulk{err: fmt.Errorf("calling to GameTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GameType.
func (c *GameTypeClient) Update() *GameTypeUpdate {
	mutation := newGameTypeMutation(c.config, OpUpdate)
	return &GameTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameTypeClient) UpdateOne(gt *GameType) *GameTypeUpdateOne {
	mutation := newGameTypeMutation(c.config, OpUpdateOne, withGameType(gt))
	return &GameTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameTypeClient) UpdateOneID(id int) *GameTypeUpdateOne {
	mutation := newGameTypeMutation(c.config, OpUpdateOne, withGameTypeID(id))
	return &GameTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GameType.
func (c *GameTypeClient) Delete() *GameTypeDelete {
	mutation := newGameTypeMutation(c.config, OpDelete)
	return &GameTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameTypeClient) DeleteOne(gt *GameType) *GameTypeDeleteOne {
	return c.DeleteOneID(gt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameTypeClient) DeleteOneID(id int) *GameTypeDeleteOne {
	builder := c.Delete().Where(gametype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameTypeDeleteOne{builder}
}

// Query returns a query builder for GameType.
func (c *GameTypeClient) Query() *GameTypeQuery {
	return &GameTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGameType},
		inters: c.Interceptors(),
	}
}

// Get returns a GameType entity by its id.
func (c *GameTypeClient) Get(ctx context.Context, id int) (*GameType, error) {
	return c.Query().Where(gametype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameTypeClient) GetX(ctx context.Context, id int) *GameType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a GameType.
func (c *GameTypeClient) QueryGames(gt *GameType) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gametype.Table, gametype.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gametype.GamesTable, gametype.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(gt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameVersions queries the game_versions edge of a GameType.
func (c *GameTypeClient) QueryGameVersions(gt *GameType) *GameVersionQuery {
	query := (&GameVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gametype.Table, gametype.FieldID, id),
			sqlgraph.To(gameversion.Table, gameversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gametype.GameVersionsTable, gametype.GameVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(gt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCurrencyVersions queries the currency_versions edge of a GameType.
func (c *GameTypeClient) QueryCurrencyVersions(gt *GameType) *CurrencyVersionQuery {
	query := (&CurrencyVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gametype.Table, gametype.FieldID, id),
			sqlgraph.To(currencyversion.Table, currencyversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gametype.CurrencyVersionsTable, gametype.CurrencyVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(gt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameTypeClient) Hooks() []Hook {
	return c.hooks.GameType
}

// Interceptors returns the client interceptors.
func (c *GameTypeClient) Interceptors() []Interceptor {
	return c.inters.GameType
}

func (c *GameTypeClient) mutate(ctx context.Context, m *GameTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GameType mutation op: %q", m.Op())
	}
}

// GameVersionClient is a client for the GameVersion schema.
type GameVersionClient struct {
	config
}

// NewGameVersionClient returns a client for the GameVersion from the given config.
func NewGameVersionClient(c config) *GameVersionClient {
	return &GameVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameversion.Hooks(f(g(h())))`.
func (c *GameVersionClient) Use(hooks ...Hook) {
	c.hooks.GameVersion = append(c.hooks.GameVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gameversion.Intercept(f(g(h())))`.
func (c *GameVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.GameVersion = append(c.inters.GameVersion, interceptors...)
}

// Create returns a builder for creating a GameVersion entity.
func (c *GameVersionClient) Create() *GameVersionCreate {
	mutation := newGameVersionMutation(c.config, OpCreate)
	return &GameVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GameVersion entities.
func (c *GameVersionClient) CreateBulk(builders ...*GameVersionCreate) *GameVersionCreateBulk {
	return &GameVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameVersionClient) MapCreateBulk(slice any, setFunc func(*GameVersionCreate, int)) *GameVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameVersionCreateBulk{err: fmt.Errorf("calling to GameVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GameVersion.
func (c *GameVersionClient) Update() *GameVersionUpdate {
	mutation := newGameVersionMutation(c.config, OpUpdate)
	return &GameVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameVersionClient) UpdateOne(gv *GameVersion) *GameVersionUpdateOne {
	mutation := newGameVersionMutation(c.config, OpUpdateOne, withGameVersion(gv))
	return &GameVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameVersionClient) UpdateOneID(id int) *GameVersionUpdateOne {
	mutation := newGameVersionMutation(c.config, OpUpdateOne, withGameVersionID(id))
	return &GameVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GameVersion.
func (c *GameVersionClient) Delete() *GameVersionDelete {
	mutation := newGameVersionMutation(c.config, OpDelete)
	return &GameVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameVersionClient) DeleteOne(gv *GameVersion) *GameVersionDeleteOne {
	return c.DeleteOneID(gv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameVersionClient) DeleteOneID(id int) *GameVersionDeleteOne {
	builder := c.Delete().Where(gameversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameVersionDeleteOne{builder}
}

// Query returns a query builder for GameVersion.
func (c *GameVersionClient) Query() *GameVersionQuery {
	return &GameVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGameVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a GameVersion entity by its id.
func (c *GameVersionClient) Get(ctx context.Context, id int) (*GameVersion, error) {
	return c.Query().Where(gameversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameVersionClient) GetX(ctx context.Context, id int) *GameVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a GameVersion.
func (c *GameVersionClient) QueryGames(gv *GameVersion) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameversion.Table, gameversion.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameversion.GamesTable, gameversion.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(gv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameType queries the game_type edge of a GameVersion.
func (c *GameVersionClient) QueryGameType(gv *GameVersion) *GameTypeQuery {
	query := (&GameTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameversion.Table, gameversion.FieldID, id),
			sqlgraph.To(gametype.Table, gametype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameversion.GameTypeTable, gameversion.GameTypeColumn),
		)
		fromV = sqlgraph.Neighbors(gv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a GameVersion.
func (c *GameVersionClient) QuerySessions(gv *GameVersion) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameversion.Table, gameversion.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gameversion.SessionsTable, gameversion.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(gv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameConfigs queries the game_configs edge of a GameVersion.
func (c *GameVersionClient) QueryGameConfigs(gv *GameVersion) *GameConfigQuery {
	query := (&GameConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameversion.Table, gameversion.FieldID, id),
			sqlgraph.To(gameconfig.Table, gameconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gameversion.GameConfigsTable, gameversion.GameConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(gv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameVersionClient) Hooks() []Hook {
	return c.hooks.GameVersion
}

// Interceptors returns the client interceptors.
func (c *GameVersionClient) Interceptors() []Interceptor {
	return c.inters.GameVersion
}

func (c *GameVersionClient) mutate(ctx context.Context, m *GameVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GameVersion mutation op: %q", m.Op())
	}
}

// MathVersionClient is a client for the MathVersion schema.
type MathVersionClient struct {
	config
}

// NewMathVersionClient returns a client for the MathVersion from the given config.
func NewMathVersionClient(c config) *MathVersionClient {
	return &MathVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mathversion.Hooks(f(g(h())))`.
func (c *MathVersionClient) Use(hooks ...Hook) {
	c.hooks.MathVersion = append(c.hooks.MathVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mathversion.Intercept(f(g(h())))`.
func (c *MathVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MathVersion = append(c.inters.MathVersion, interceptors...)
}

// Create returns a builder for creating a MathVersion entity.
func (c *MathVersionClient) Create() *MathVersionCreate {
	mutation := newMathVersionMutation(c.config, OpCreate)
	return &MathVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MathVersion entities.
func (c *MathVersionClient) CreateBulk(builders ...*MathVersionCreate) *MathVersionCreateBulk {
	return &MathVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MathVersionClient) MapCreateBulk(slice any, setFunc func(*MathVersionCreate, int)) *MathVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MathVersionCreateBulk{err: fmt.Errorf("calling to MathVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MathVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MathVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MathVersion.
func (c *MathVersionClient) Update() *MathVersionUpdate {
	mutation := newMathVersionMutation(c.config, OpUpdate)
	return &MathVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MathVersionClient) UpdateOne(mv *MathVersion) *MathVersionUpdateOne {
	mutation := newMathVersionMutation(c.config, OpUpdateOne, withMathVersion(mv))
	return &MathVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MathVersionClient) UpdateOneID(id int) *MathVersionUpdateOne {
	mutation := newMathVersionMutation(c.config, OpUpdateOne, withMathVersionID(id))
	return &MathVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MathVersion.
func (c *MathVersionClient) Delete() *MathVersionDelete {
	mutation := newMathVersionMutation(c.config, OpDelete)
	return &MathVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MathVersionClient) DeleteOne(mv *MathVersion) *MathVersionDeleteOne {
	return c.DeleteOneID(mv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MathVersionClient) DeleteOneID(id int) *MathVersionDeleteOne {
	builder := c.Delete().Where(mathversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MathVersionDeleteOne{builder}
}

// Query returns a query builder for MathVersion.
func (c *MathVersionClient) Query() *MathVersionQuery {
	return &MathVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMathVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a MathVersion entity by its id.
func (c *MathVersionClient) Get(ctx context.Context, id int) (*MathVersion, error) {
	return c.Query().Where(mathversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MathVersionClient) GetX(ctx context.Context, id int) *MathVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a MathVersion.
func (c *MathVersionClient) QuerySessions(mv *MathVersion) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mathversion.Table, mathversion.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mathversion.SessionsTable, mathversion.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(mv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameConfigs queries the game_configs edge of a MathVersion.
func (c *MathVersionClient) QueryGameConfigs(mv *MathVersion) *GameConfigQuery {
	query := (&GameConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mathversion.Table, mathversion.FieldID, id),
			sqlgraph.To(gameconfig.Table, gameconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mathversion.GameConfigsTable, mathversion.GameConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(mv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MathVersionClient) Hooks() []Hook {
	return c.hooks.MathVersion
}

// Interceptors returns the client interceptors.
func (c *MathVersionClient) Interceptors() []Interceptor {
	return c.inters.MathVersion
}

func (c *MathVersionClient) mutate(ctx context.Context, m *MathVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MathVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MathVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MathVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MathVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MathVersion mutation op: %q", m.Op())
	}
}

// OperatorClient is a client for the Operator schema.
type OperatorClient struct {
	config
}

// NewOperatorClient returns a client for the Operator from the given config.
func NewOperatorClient(c config) *OperatorClient {
	return &OperatorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `operator.Hooks(f(g(h())))`.
func (c *OperatorClient) Use(hooks ...Hook) {
	c.hooks.Operator = append(c.hooks.Operator, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `operator.Intercept(f(g(h())))`.
func (c *OperatorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Operator = append(c.inters.Operator, interceptors...)
}

// Create returns a builder for creating a Operator entity.
func (c *OperatorClient) Create() *OperatorCreate {
	mutation := newOperatorMutation(c.config, OpCreate)
	return &OperatorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Operator entities.
func (c *OperatorClient) CreateBulk(builders ...*OperatorCreate) *OperatorCreateBulk {
	return &OperatorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OperatorClient) MapCreateBulk(slice any, setFunc func(*OperatorCreate, int)) *OperatorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OperatorCreateBulk{err: fmt.Errorf("calling to OperatorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OperatorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OperatorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Operator.
func (c *OperatorClient) Update() *OperatorUpdate {
	mutation := newOperatorMutation(c.config, OpUpdate)
	return &OperatorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OperatorClient) UpdateOne(o *Operator) *OperatorUpdateOne {
	mutation := newOperatorMutation(c.config, OpUpdateOne, withOperator(o))
	return &OperatorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OperatorClient) UpdateOneID(id int) *OperatorUpdateOne {
	mutation := newOperatorMutation(c.config, OpUpdateOne, withOperatorID(id))
	return &OperatorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Operator.
func (c *OperatorClient) Delete() *OperatorDelete {
	mutation := newOperatorMutation(c.config, OpDelete)
	return &OperatorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OperatorClient) DeleteOne(o *Operator) *OperatorDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OperatorClient) DeleteOneID(id int) *OperatorDeleteOne {
	builder := c.Delete().Where(operator.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OperatorDeleteOne{builder}
}

// Query returns a query builder for Operator.
func (c *OperatorClient) Query() *OperatorQuery {
	return &OperatorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOperator},
		inters: c.Interceptors(),
	}
}

// Get returns a Operator entity by its id.
func (c *OperatorClient) Get(ctx context.Context, id int) (*Operator, error) {
	return c.Query().Where(operator.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OperatorClient) GetX(ctx context.Context, id int) *Operator {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlatforms queries the platforms edge of a Operator.
func (c *OperatorClient) QueryPlatforms(o *Operator) *PlatformQuery {
	query := (&PlatformClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(operator.Table, operator.FieldID, id),
			sqlgraph.To(platform.Table, platform.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, operator.PlatformsTable, operator.PlatformsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a Operator.
func (c *OperatorClient) QuerySessions(o *Operator) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(operator.Table, operator.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, operator.SessionsTable, operator.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameConfigs queries the game_configs edge of a Operator.
func (c *OperatorClient) QueryGameConfigs(o *Operator) *GameConfigQuery {
	query := (&GameConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(operator.Table, operator.FieldID, id),
			sqlgraph.To(gameconfig.Table, gameconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, operator.GameConfigsTable, operator.GameConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OperatorClient) Hooks() []Hook {
	return c.hooks.Operator
}

// Interceptors returns the client interceptors.
func (c *OperatorClient) Interceptors() []Interceptor {
	return c.inters.Operator
}

func (c *OperatorClient) mutate(ctx context.Context, m *OperatorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OperatorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OperatorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OperatorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OperatorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Operator mutation op: %q", m.Op())
	}
}

// PlatformClient is a client for the Platform schema.
type PlatformClient struct {
	config
}

// NewPlatformClient returns a client for the Platform from the given config.
func NewPlatformClient(c config) *PlatformClient {
	return &PlatformClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `platform.Hooks(f(g(h())))`.
func (c *PlatformClient) Use(hooks ...Hook) {
	c.hooks.Platform = append(c.hooks.Platform, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `platform.Intercept(f(g(h())))`.
func (c *PlatformClient) Intercept(interceptors ...Interceptor) {
	c.inters.Platform = append(c.inters.Platform, interceptors...)
}

// Create returns a builder for creating a Platform entity.
func (c *PlatformClient) Create() *PlatformCreate {
	mutation := newPlatformMutation(c.config, OpCreate)
	return &PlatformCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Platform entities.
func (c *PlatformClient) CreateBulk(builders ...*PlatformCreate) *PlatformCreateBulk {
	return &PlatformCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlatformClient) MapCreateBulk(slice any, setFunc func(*PlatformCreate, int)) *PlatformCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlatformCreateBulk{err: fmt.Errorf("calling to PlatformClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlatformCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlatformCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Platform.
func (c *PlatformClient) Update() *PlatformUpdate {
	mutation := newPlatformMutation(c.config, OpUpdate)
	return &PlatformUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlatformClient) UpdateOne(pl *Platform) *PlatformUpdateOne {
	mutation := newPlatformMutation(c.config, OpUpdateOne, withPlatform(pl))
	return &PlatformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlatformClient) UpdateOneID(id int) *PlatformUpdateOne {
	mutation := newPlatformMutation(c.config, OpUpdateOne, withPlatformID(id))
	return &PlatformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Platform.
func (c *PlatformClient) Delete() *PlatformDelete {
	mutation := newPlatformMutation(c.config, OpDelete)
	return &PlatformDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlatformClient) DeleteOne(pl *Platform) *PlatformDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlatformClient) DeleteOneID(id int) *PlatformDeleteOne {
	builder := c.Delete().Where(platform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlatformDeleteOne{builder}
}

// Query returns a query builder for Platform.
func (c *PlatformClient) Query() *PlatformQuery {
	return &PlatformQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlatform},
		inters: c.Interceptors(),
	}
}

// Get returns a Platform entity by its id.
func (c *PlatformClient) Get(ctx context.Context, id int) (*Platform, error) {
	return c.Query().Where(platform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlatformClient) GetX(ctx context.Context, id int) *Platform {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOperator queries the Operator edge of a Platform.
func (c *PlatformClient) QueryOperator(pl *Platform) *OperatorQuery {
	query := (&OperatorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(platform.Table, platform.FieldID, id),
			sqlgraph.To(operator.Table, operator.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, platform.OperatorTable, platform.OperatorColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlatformClient) Hooks() []Hook {
	return c.hooks.Platform
}

// Interceptors returns the client interceptors.
func (c *PlatformClient) Interceptors() []Interceptor {
	return c.inters.Platform
}

func (c *PlatformClient) mutate(ctx context.Context, m *PlatformMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlatformCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlatformUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlatformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlatformDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Platform mutation op: %q", m.Op())
	}
}

// SerieClient is a client for the Serie schema.
type SerieClient struct {
	config
}

// NewSerieClient returns a client for the Serie from the given config.
func NewSerieClient(c config) *SerieClient {
	return &SerieClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serie.Hooks(f(g(h())))`.
func (c *SerieClient) Use(hooks ...Hook) {
	c.hooks.Serie = append(c.hooks.Serie, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serie.Intercept(f(g(h())))`.
func (c *SerieClient) Intercept(interceptors ...Interceptor) {
	c.inters.Serie = append(c.inters.Serie, interceptors...)
}

// Create returns a builder for creating a Serie entity.
func (c *SerieClient) Create() *SerieCreate {
	mutation := newSerieMutation(c.config, OpCreate)
	return &SerieCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Serie entities.
func (c *SerieClient) CreateBulk(builders ...*SerieCreate) *SerieCreateBulk {
	return &SerieCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SerieClient) MapCreateBulk(slice any, setFunc func(*SerieCreate, int)) *SerieCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SerieCreateBulk{err: fmt.Errorf("calling to SerieClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SerieCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SerieCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Serie.
func (c *SerieClient) Update() *SerieUpdate {
	mutation := newSerieMutation(c.config, OpUpdate)
	return &SerieUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SerieClient) UpdateOne(s *Serie) *SerieUpdateOne {
	mutation := newSerieMutation(c.config, OpUpdateOne, withSerie(s))
	return &SerieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SerieClient) UpdateOneID(id int) *SerieUpdateOne {
	mutation := newSerieMutation(c.config, OpUpdateOne, withSerieID(id))
	return &SerieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Serie.
func (c *SerieClient) Delete() *SerieDelete {
	mutation := newSerieMutation(c.config, OpDelete)
	return &SerieDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SerieClient) DeleteOne(s *Serie) *SerieDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SerieClient) DeleteOneID(id int) *SerieDeleteOne {
	builder := c.Delete().Where(serie.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SerieDeleteOne{builder}
}

// Query returns a query builder for Serie.
func (c *SerieClient) Query() *SerieQuery {
	return &SerieQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSerie},
		inters: c.Interceptors(),
	}
}

// Get returns a Serie entity by its id.
func (c *SerieClient) Get(ctx context.Context, id int) (*Serie, error) {
	return c.Query().Where(serie.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SerieClient) GetX(ctx context.Context, id int) *Serie {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Serie.
func (c *SerieClient) QueryGames(s *Serie) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serie.Table, serie.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serie.GamesTable, serie.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySerieFeatures queries the serie_features edge of a Serie.
func (c *SerieClient) QuerySerieFeatures(s *Serie) *SerieFeatureQuery {
	query := (&SerieFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serie.Table, serie.FieldID, id),
			sqlgraph.To(seriefeature.Table, seriefeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serie.SerieFeaturesTable, serie.SerieFeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SerieClient) Hooks() []Hook {
	return c.hooks.Serie
}

// Interceptors returns the client interceptors.
func (c *SerieClient) Interceptors() []Interceptor {
	return c.inters.Serie
}

func (c *SerieClient) mutate(ctx context.Context, m *SerieMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SerieCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SerieUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SerieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SerieDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Serie mutation op: %q", m.Op())
	}
}

// SerieFeatureClient is a client for the SerieFeature schema.
type SerieFeatureClient struct {
	config
}

// NewSerieFeatureClient returns a client for the SerieFeature from the given config.
func NewSerieFeatureClient(c config) *SerieFeatureClient {
	return &SerieFeatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seriefeature.Hooks(f(g(h())))`.
func (c *SerieFeatureClient) Use(hooks ...Hook) {
	c.hooks.SerieFeature = append(c.hooks.SerieFeature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seriefeature.Intercept(f(g(h())))`.
func (c *SerieFeatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.SerieFeature = append(c.inters.SerieFeature, interceptors...)
}

// Create returns a builder for creating a SerieFeature entity.
func (c *SerieFeatureClient) Create() *SerieFeatureCreate {
	mutation := newSerieFeatureMutation(c.config, OpCreate)
	return &SerieFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SerieFeature entities.
func (c *SerieFeatureClient) CreateBulk(builders ...*SerieFeatureCreate) *SerieFeatureCreateBulk {
	return &SerieFeatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SerieFeatureClient) MapCreateBulk(slice any, setFunc func(*SerieFeatureCreate, int)) *SerieFeatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SerieFeatureCreateBulk{err: fmt.Errorf("calling to SerieFeatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SerieFeatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SerieFeatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SerieFeature.
func (c *SerieFeatureClient) Update() *SerieFeatureUpdate {
	mutation := newSerieFeatureMutation(c.config, OpUpdate)
	return &SerieFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SerieFeatureClient) UpdateOne(sf *SerieFeature) *SerieFeatureUpdateOne {
	mutation := newSerieFeatureMutation(c.config, OpUpdateOne, withSerieFeature(sf))
	return &SerieFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SerieFeatureClient) UpdateOneID(id int) *SerieFeatureUpdateOne {
	mutation := newSerieFeatureMutation(c.config, OpUpdateOne, withSerieFeatureID(id))
	return &SerieFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SerieFeature.
func (c *SerieFeatureClient) Delete() *SerieFeatureDelete {
	mutation := newSerieFeatureMutation(c.config, OpDelete)
	return &SerieFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SerieFeatureClient) DeleteOne(sf *SerieFeature) *SerieFeatureDeleteOne {
	return c.DeleteOneID(sf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SerieFeatureClient) DeleteOneID(id int) *SerieFeatureDeleteOne {
	builder := c.Delete().Where(seriefeature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SerieFeatureDeleteOne{builder}
}

// Query returns a query builder for SerieFeature.
func (c *SerieFeatureClient) Query() *SerieFeatureQuery {
	return &SerieFeatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSerieFeature},
		inters: c.Interceptors(),
	}
}

// Get returns a SerieFeature entity by its id.
func (c *SerieFeatureClient) Get(ctx context.Context, id int) (*SerieFeature, error) {
	return c.Query().Where(seriefeature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SerieFeatureClient) GetX(ctx context.Context, id int) *SerieFeature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFeatures queries the features edge of a SerieFeature.
func (c *SerieFeatureClient) QueryFeatures(sf *SerieFeature) *FeatureQuery {
	query := (&FeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seriefeature.Table, seriefeature.FieldID, id),
			sqlgraph.To(feature.Table, feature.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seriefeature.FeaturesTable, seriefeature.FeaturesColumn),
		)
		fromV = sqlgraph.Neighbors(sf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeries queries the series edge of a SerieFeature.
func (c *SerieFeatureClient) QuerySeries(sf *SerieFeature) *SerieQuery {
	query := (&SerieClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seriefeature.Table, seriefeature.FieldID, id),
			sqlgraph.To(serie.Table, serie.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seriefeature.SeriesTable, seriefeature.SeriesColumn),
		)
		fromV = sqlgraph.Neighbors(sf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SerieFeatureClient) Hooks() []Hook {
	return c.hooks.SerieFeature
}

// Interceptors returns the client interceptors.
func (c *SerieFeatureClient) Interceptors() []Interceptor {
	return c.inters.SerieFeature
}

func (c *SerieFeatureClient) mutate(ctx context.Context, m *SerieFeatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SerieFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SerieFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SerieFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SerieFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SerieFeature mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id int) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id int) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id int) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id int) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Session.
func (c *SessionClient) QueryGames(s *Session) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.GamesTable, session.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameVersions queries the game_versions edge of a Session.
func (c *SessionClient) QueryGameVersions(s *Session) *GameVersionQuery {
	query := (&GameVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(gameversion.Table, gameversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.GameVersionsTable, session.GameVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOperator queries the Operator edge of a Session.
func (c *SessionClient) QueryOperator(s *Session) *OperatorQuery {
	query := (&OperatorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(operator.Table, operator.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.OperatorTable, session.OperatorColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCurrencyVersions queries the currency_versions edge of a Session.
func (c *SessionClient) QueryCurrencyVersions(s *Session) *CurrencyVersionQuery {
	query := (&CurrencyVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(currencyversion.Table, currencyversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.CurrencyVersionsTable, session.CurrencyVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMathVersions queries the math_versions edge of a Session.
func (c *SessionClient) QueryMathVersions(s *Session) *MathVersionQuery {
	query := (&MathVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(mathversion.Table, mathversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.MathVersionsTable, session.MathVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// StudioClient is a client for the Studio schema.
type StudioClient struct {
	config
}

// NewStudioClient returns a client for the Studio from the given config.
func NewStudioClient(c config) *StudioClient {
	return &StudioClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `studio.Hooks(f(g(h())))`.
func (c *StudioClient) Use(hooks ...Hook) {
	c.hooks.Studio = append(c.hooks.Studio, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `studio.Intercept(f(g(h())))`.
func (c *StudioClient) Intercept(interceptors ...Interceptor) {
	c.inters.Studio = append(c.inters.Studio, interceptors...)
}

// Create returns a builder for creating a Studio entity.
func (c *StudioClient) Create() *StudioCreate {
	mutation := newStudioMutation(c.config, OpCreate)
	return &StudioCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Studio entities.
func (c *StudioClient) CreateBulk(builders ...*StudioCreate) *StudioCreateBulk {
	return &StudioCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StudioClient) MapCreateBulk(slice any, setFunc func(*StudioCreate, int)) *StudioCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StudioCreateBulk{err: fmt.Errorf("calling to StudioClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StudioCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StudioCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Studio.
func (c *StudioClient) Update() *StudioUpdate {
	mutation := newStudioMutation(c.config, OpUpdate)
	return &StudioUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StudioClient) UpdateOne(s *Studio) *StudioUpdateOne {
	mutation := newStudioMutation(c.config, OpUpdateOne, withStudio(s))
	return &StudioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StudioClient) UpdateOneID(id int) *StudioUpdateOne {
	mutation := newStudioMutation(c.config, OpUpdateOne, withStudioID(id))
	return &StudioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Studio.
func (c *StudioClient) Delete() *StudioDelete {
	mutation := newStudioMutation(c.config, OpDelete)
	return &StudioDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StudioClient) DeleteOne(s *Studio) *StudioDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StudioClient) DeleteOneID(id int) *StudioDeleteOne {
	builder := c.Delete().Where(studio.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StudioDeleteOne{builder}
}

// Query returns a query builder for Studio.
func (c *StudioClient) Query() *StudioQuery {
	return &StudioQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStudio},
		inters: c.Interceptors(),
	}
}

// Get returns a Studio entity by its id.
func (c *StudioClient) Get(ctx context.Context, id int) (*Studio, error) {
	return c.Query().Where(studio.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StudioClient) GetX(ctx context.Context, id int) *Studio {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Studio.
func (c *StudioClient) QueryGames(s *Studio) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(studio.Table, studio.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, studio.GamesTable, studio.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StudioClient) Hooks() []Hook {
	return c.hooks.Studio
}

// Interceptors returns the client interceptors.
func (c *StudioClient) Interceptors() []Interceptor {
	return c.inters.Studio
}

func (c *StudioClient) mutate(ctx context.Context, m *StudioMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StudioCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StudioUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StudioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StudioDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Studio mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Currency, CurrencyVersion, Feature, Game, GameConfig, GameFeature, GameType,
		GameVersion, MathVersion, Operator, Platform, Serie, SerieFeature, Session,
		Studio []ent.Hook
	}
	inters struct {
		Currency, CurrencyVersion, Feature, Game, GameConfig, GameFeature, GameType,
		GameVersion, MathVersion, Operator, Platform, Serie, SerieFeature, Session,
		Studio []ent.Interceptor
	}
)
