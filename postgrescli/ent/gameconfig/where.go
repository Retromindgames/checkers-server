// Code generated by ent, DO NOT EDIT.

package gameconfig

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Lavizord/checkers-server/postgrescli/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldLTE(FieldID, id))
}

// CanDemo applies equality check predicate on the "can_demo" field. It's identical to CanDemoEQ.
func CanDemo(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanDemo, v))
}

// CanTournament applies equality check predicate on the "can_tournament" field. It's identical to CanTournamentEQ.
func CanTournament(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanTournament, v))
}

// CanFreeBets applies equality check predicate on the "can_free_bets" field. It's identical to CanFreeBetsEQ.
func CanFreeBets(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanFreeBets, v))
}

// CanDropAndWins applies equality check predicate on the "can_drop_and_wins" field. It's identical to CanDropAndWinsEQ.
func CanDropAndWins(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanDropAndWins, v))
}

// CanTurbo applies equality check predicate on the "can_turbo" field. It's identical to CanTurboEQ.
func CanTurbo(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanTurbo, v))
}

// IsActive applies equality check predicate on the "is_active" field. It's identical to IsActiveEQ.
func IsActive(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldIsActive, v))
}

// CanAutoBet applies equality check predicate on the "can_auto_bet" field. It's identical to CanAutoBetEQ.
func CanAutoBet(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanAutoBet, v))
}

// CanAutoCashout applies equality check predicate on the "can_auto_cashout" field. It's identical to CanAutoCashoutEQ.
func CanAutoCashout(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanAutoCashout, v))
}

// CanAnteBet applies equality check predicate on the "can_ante_bet" field. It's identical to CanAnteBetEQ.
func CanAnteBet(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanAnteBet, v))
}

// CanHomeButton applies equality check predicate on the "can_home_button" field. It's identical to CanHomeButtonEQ.
func CanHomeButton(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanHomeButton, v))
}

// CanDemoEQ applies the EQ predicate on the "can_demo" field.
func CanDemoEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanDemo, v))
}

// CanDemoNEQ applies the NEQ predicate on the "can_demo" field.
func CanDemoNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanDemo, v))
}

// CanTournamentEQ applies the EQ predicate on the "can_tournament" field.
func CanTournamentEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanTournament, v))
}

// CanTournamentNEQ applies the NEQ predicate on the "can_tournament" field.
func CanTournamentNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanTournament, v))
}

// CanFreeBetsEQ applies the EQ predicate on the "can_free_bets" field.
func CanFreeBetsEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanFreeBets, v))
}

// CanFreeBetsNEQ applies the NEQ predicate on the "can_free_bets" field.
func CanFreeBetsNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanFreeBets, v))
}

// CanDropAndWinsEQ applies the EQ predicate on the "can_drop_and_wins" field.
func CanDropAndWinsEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanDropAndWins, v))
}

// CanDropAndWinsNEQ applies the NEQ predicate on the "can_drop_and_wins" field.
func CanDropAndWinsNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanDropAndWins, v))
}

// CanTurboEQ applies the EQ predicate on the "can_turbo" field.
func CanTurboEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanTurbo, v))
}

// CanTurboNEQ applies the NEQ predicate on the "can_turbo" field.
func CanTurboNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanTurbo, v))
}

// IsActiveEQ applies the EQ predicate on the "is_active" field.
func IsActiveEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldIsActive, v))
}

// IsActiveNEQ applies the NEQ predicate on the "is_active" field.
func IsActiveNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldIsActive, v))
}

// CanAutoBetEQ applies the EQ predicate on the "can_auto_bet" field.
func CanAutoBetEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanAutoBet, v))
}

// CanAutoBetNEQ applies the NEQ predicate on the "can_auto_bet" field.
func CanAutoBetNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanAutoBet, v))
}

// CanAutoCashoutEQ applies the EQ predicate on the "can_auto_cashout" field.
func CanAutoCashoutEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanAutoCashout, v))
}

// CanAutoCashoutNEQ applies the NEQ predicate on the "can_auto_cashout" field.
func CanAutoCashoutNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanAutoCashout, v))
}

// CanAnteBetEQ applies the EQ predicate on the "can_ante_bet" field.
func CanAnteBetEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanAnteBet, v))
}

// CanAnteBetNEQ applies the NEQ predicate on the "can_ante_bet" field.
func CanAnteBetNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanAnteBet, v))
}

// CanHomeButtonEQ applies the EQ predicate on the "can_home_button" field.
func CanHomeButtonEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldEQ(FieldCanHomeButton, v))
}

// CanHomeButtonNEQ applies the NEQ predicate on the "can_home_button" field.
func CanHomeButtonNEQ(v bool) predicate.GameConfig {
	return predicate.GameConfig(sql.FieldNEQ(FieldCanHomeButton, v))
}

// HasMathVersions applies the HasEdge predicate on the "math_versions" edge.
func HasMathVersions() predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, MathVersionsTable, MathVersionsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasMathVersionsWith applies the HasEdge predicate on the "math_versions" edge with a given conditions (other predicates).
func HasMathVersionsWith(preds ...predicate.MathVersion) predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := newMathVersionsStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasGameVersions applies the HasEdge predicate on the "game_versions" edge.
func HasGameVersions() predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, GameVersionsTable, GameVersionsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasGameVersionsWith applies the HasEdge predicate on the "game_versions" edge with a given conditions (other predicates).
func HasGameVersionsWith(preds ...predicate.GameVersion) predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := newGameVersionsStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasGames applies the HasEdge predicate on the "games" edge.
func HasGames() predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, GamesTable, GamesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasGamesWith applies the HasEdge predicate on the "games" edge with a given conditions (other predicates).
func HasGamesWith(preds ...predicate.Game) predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := newGamesStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasOperator applies the HasEdge predicate on the "Operator" edge.
func HasOperator() predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, OperatorTable, OperatorColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasOperatorWith applies the HasEdge predicate on the "Operator" edge with a given conditions (other predicates).
func HasOperatorWith(preds ...predicate.Operator) predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := newOperatorStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCurrencyVersions applies the HasEdge predicate on the "currency_versions" edge.
func HasCurrencyVersions() predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CurrencyVersionsTable, CurrencyVersionsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCurrencyVersionsWith applies the HasEdge predicate on the "currency_versions" edge with a given conditions (other predicates).
func HasCurrencyVersionsWith(preds ...predicate.CurrencyVersion) predicate.GameConfig {
	return predicate.GameConfig(func(s *sql.Selector) {
		step := newCurrencyVersionsStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.GameConfig) predicate.GameConfig {
	return predicate.GameConfig(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.GameConfig) predicate.GameConfig {
	return predicate.GameConfig(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.GameConfig) predicate.GameConfig {
	return predicate.GameConfig(sql.NotPredicates(p))
}
