// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Lavizord/checkers-server/postgrescli/ent/currencie"
	"github.com/Lavizord/checkers-server/postgrescli/ent/currencyversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/feature"
	"github.com/Lavizord/checkers-server/postgrescli/ent/game"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gameconfig"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gamefeature"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gametype"
	"github.com/Lavizord/checkers-server/postgrescli/ent/gameversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/mathversion"
	"github.com/Lavizord/checkers-server/postgrescli/ent/operator"
	"github.com/Lavizord/checkers-server/postgrescli/ent/platform"
	"github.com/Lavizord/checkers-server/postgrescli/ent/predicate"
	"github.com/Lavizord/checkers-server/postgrescli/ent/serie"
	"github.com/Lavizord/checkers-server/postgrescli/ent/seriefeature"
	"github.com/Lavizord/checkers-server/postgrescli/ent/session"
	"github.com/Lavizord/checkers-server/postgrescli/ent/studio"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCurrencie       = "Currencie"
	TypeCurrencyVersion = "CurrencyVersion"
	TypeFeature         = "Feature"
	TypeGame            = "Game"
	TypeGameConfig      = "GameConfig"
	TypeGameFeature     = "GameFeature"
	TypeGameType        = "GameType"
	TypeGameVersion     = "GameVersion"
	TypeMathVersion     = "MathVersion"
	TypeOperator        = "Operator"
	TypePlatform        = "Platform"
	TypeSerie           = "Serie"
	TypeSerieFeature    = "SerieFeature"
	TypeSession         = "Session"
	TypeStudio          = "Studio"
)

// CurrencieMutation represents an operation that mutates the Currencie nodes in the graph.
type CurrencieMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	symbol                   *string
	thousands_separator      *string
	units_separator          *string
	symbol_position          *string
	denominator              *int
	adddenominator           *int
	clearedFields            map[string]struct{}
	currency_versions        map[int]struct{}
	removedcurrency_versions map[int]struct{}
	clearedcurrency_versions bool
	done                     bool
	oldValue                 func(context.Context) (*Currencie, error)
	predicates               []predicate.Currencie
}

var _ ent.Mutation = (*CurrencieMutation)(nil)

// currencieOption allows management of the mutation configuration using functional options.
type currencieOption func(*CurrencieMutation)

// newCurrencieMutation creates new mutation for the Currencie entity.
func newCurrencieMutation(c config, op Op, opts ...currencieOption) *CurrencieMutation {
	m := &CurrencieMutation{
		config:        c,
		op:            op,
		typ:           TypeCurrencie,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCurrencieID sets the ID field of the mutation.
func withCurrencieID(id int) currencieOption {
	return func(m *CurrencieMutation) {
		var (
			err   error
			once  sync.Once
			value *Currencie
		)
		m.oldValue = func(ctx context.Context) (*Currencie, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Currencie.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCurrencie sets the old Currencie of the mutation.
func withCurrencie(node *Currencie) currencieOption {
	return func(m *CurrencieMutation) {
		m.oldValue = func(context.Context) (*Currencie, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CurrencieMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CurrencieMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CurrencieMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CurrencieMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Currencie.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CurrencieMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CurrencieMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Currencie entity.
// If the Currencie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencieMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CurrencieMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *CurrencieMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *CurrencieMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Currencie entity.
// If the Currencie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencieMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *CurrencieMutation) ResetSymbol() {
	m.symbol = nil
}

// SetThousandsSeparator sets the "thousands_separator" field.
func (m *CurrencieMutation) SetThousandsSeparator(s string) {
	m.thousands_separator = &s
}

// ThousandsSeparator returns the value of the "thousands_separator" field in the mutation.
func (m *CurrencieMutation) ThousandsSeparator() (r string, exists bool) {
	v := m.thousands_separator
	if v == nil {
		return
	}
	return *v, true
}

// OldThousandsSeparator returns the old "thousands_separator" field's value of the Currencie entity.
// If the Currencie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencieMutation) OldThousandsSeparator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThousandsSeparator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThousandsSeparator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThousandsSeparator: %w", err)
	}
	return oldValue.ThousandsSeparator, nil
}

// ResetThousandsSeparator resets all changes to the "thousands_separator" field.
func (m *CurrencieMutation) ResetThousandsSeparator() {
	m.thousands_separator = nil
}

// SetUnitsSeparator sets the "units_separator" field.
func (m *CurrencieMutation) SetUnitsSeparator(s string) {
	m.units_separator = &s
}

// UnitsSeparator returns the value of the "units_separator" field in the mutation.
func (m *CurrencieMutation) UnitsSeparator() (r string, exists bool) {
	v := m.units_separator
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitsSeparator returns the old "units_separator" field's value of the Currencie entity.
// If the Currencie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencieMutation) OldUnitsSeparator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitsSeparator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitsSeparator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitsSeparator: %w", err)
	}
	return oldValue.UnitsSeparator, nil
}

// ResetUnitsSeparator resets all changes to the "units_separator" field.
func (m *CurrencieMutation) ResetUnitsSeparator() {
	m.units_separator = nil
}

// SetSymbolPosition sets the "symbol_position" field.
func (m *CurrencieMutation) SetSymbolPosition(s string) {
	m.symbol_position = &s
}

// SymbolPosition returns the value of the "symbol_position" field in the mutation.
func (m *CurrencieMutation) SymbolPosition() (r string, exists bool) {
	v := m.symbol_position
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolPosition returns the old "symbol_position" field's value of the Currencie entity.
// If the Currencie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencieMutation) OldSymbolPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolPosition: %w", err)
	}
	return oldValue.SymbolPosition, nil
}

// ResetSymbolPosition resets all changes to the "symbol_position" field.
func (m *CurrencieMutation) ResetSymbolPosition() {
	m.symbol_position = nil
}

// SetDenominator sets the "denominator" field.
func (m *CurrencieMutation) SetDenominator(i int) {
	m.denominator = &i
	m.adddenominator = nil
}

// Denominator returns the value of the "denominator" field in the mutation.
func (m *CurrencieMutation) Denominator() (r int, exists bool) {
	v := m.denominator
	if v == nil {
		return
	}
	return *v, true
}

// OldDenominator returns the old "denominator" field's value of the Currencie entity.
// If the Currencie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencieMutation) OldDenominator(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenominator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenominator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenominator: %w", err)
	}
	return oldValue.Denominator, nil
}

// AddDenominator adds i to the "denominator" field.
func (m *CurrencieMutation) AddDenominator(i int) {
	if m.adddenominator != nil {
		*m.adddenominator += i
	} else {
		m.adddenominator = &i
	}
}

// AddedDenominator returns the value that was added to the "denominator" field in this mutation.
func (m *CurrencieMutation) AddedDenominator() (r int, exists bool) {
	v := m.adddenominator
	if v == nil {
		return
	}
	return *v, true
}

// ResetDenominator resets all changes to the "denominator" field.
func (m *CurrencieMutation) ResetDenominator() {
	m.denominator = nil
	m.adddenominator = nil
}

// AddCurrencyVersionIDs adds the "currency_versions" edge to the CurrencyVersion entity by ids.
func (m *CurrencieMutation) AddCurrencyVersionIDs(ids ...int) {
	if m.currency_versions == nil {
		m.currency_versions = make(map[int]struct{})
	}
	for i := range ids {
		m.currency_versions[ids[i]] = struct{}{}
	}
}

// ClearCurrencyVersions clears the "currency_versions" edge to the CurrencyVersion entity.
func (m *CurrencieMutation) ClearCurrencyVersions() {
	m.clearedcurrency_versions = true
}

// CurrencyVersionsCleared reports if the "currency_versions" edge to the CurrencyVersion entity was cleared.
func (m *CurrencieMutation) CurrencyVersionsCleared() bool {
	return m.clearedcurrency_versions
}

// RemoveCurrencyVersionIDs removes the "currency_versions" edge to the CurrencyVersion entity by IDs.
func (m *CurrencieMutation) RemoveCurrencyVersionIDs(ids ...int) {
	if m.removedcurrency_versions == nil {
		m.removedcurrency_versions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.currency_versions, ids[i])
		m.removedcurrency_versions[ids[i]] = struct{}{}
	}
}

// RemovedCurrencyVersions returns the removed IDs of the "currency_versions" edge to the CurrencyVersion entity.
func (m *CurrencieMutation) RemovedCurrencyVersionsIDs() (ids []int) {
	for id := range m.removedcurrency_versions {
		ids = append(ids, id)
	}
	return
}

// CurrencyVersionsIDs returns the "currency_versions" edge IDs in the mutation.
func (m *CurrencieMutation) CurrencyVersionsIDs() (ids []int) {
	for id := range m.currency_versions {
		ids = append(ids, id)
	}
	return
}

// ResetCurrencyVersions resets all changes to the "currency_versions" edge.
func (m *CurrencieMutation) ResetCurrencyVersions() {
	m.currency_versions = nil
	m.clearedcurrency_versions = false
	m.removedcurrency_versions = nil
}

// Where appends a list predicates to the CurrencieMutation builder.
func (m *CurrencieMutation) Where(ps ...predicate.Currencie) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CurrencieMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CurrencieMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Currencie, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CurrencieMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CurrencieMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Currencie).
func (m *CurrencieMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CurrencieMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, currencie.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, currencie.FieldSymbol)
	}
	if m.thousands_separator != nil {
		fields = append(fields, currencie.FieldThousandsSeparator)
	}
	if m.units_separator != nil {
		fields = append(fields, currencie.FieldUnitsSeparator)
	}
	if m.symbol_position != nil {
		fields = append(fields, currencie.FieldSymbolPosition)
	}
	if m.denominator != nil {
		fields = append(fields, currencie.FieldDenominator)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CurrencieMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case currencie.FieldName:
		return m.Name()
	case currencie.FieldSymbol:
		return m.Symbol()
	case currencie.FieldThousandsSeparator:
		return m.ThousandsSeparator()
	case currencie.FieldUnitsSeparator:
		return m.UnitsSeparator()
	case currencie.FieldSymbolPosition:
		return m.SymbolPosition()
	case currencie.FieldDenominator:
		return m.Denominator()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CurrencieMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case currencie.FieldName:
		return m.OldName(ctx)
	case currencie.FieldSymbol:
		return m.OldSymbol(ctx)
	case currencie.FieldThousandsSeparator:
		return m.OldThousandsSeparator(ctx)
	case currencie.FieldUnitsSeparator:
		return m.OldUnitsSeparator(ctx)
	case currencie.FieldSymbolPosition:
		return m.OldSymbolPosition(ctx)
	case currencie.FieldDenominator:
		return m.OldDenominator(ctx)
	}
	return nil, fmt.Errorf("unknown Currencie field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencieMutation) SetField(name string, value ent.Value) error {
	switch name {
	case currencie.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case currencie.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case currencie.FieldThousandsSeparator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThousandsSeparator(v)
		return nil
	case currencie.FieldUnitsSeparator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitsSeparator(v)
		return nil
	case currencie.FieldSymbolPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolPosition(v)
		return nil
	case currencie.FieldDenominator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenominator(v)
		return nil
	}
	return fmt.Errorf("unknown Currencie field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CurrencieMutation) AddedFields() []string {
	var fields []string
	if m.adddenominator != nil {
		fields = append(fields, currencie.FieldDenominator)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CurrencieMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case currencie.FieldDenominator:
		return m.AddedDenominator()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencieMutation) AddField(name string, value ent.Value) error {
	switch name {
	case currencie.FieldDenominator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDenominator(v)
		return nil
	}
	return fmt.Errorf("unknown Currencie numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CurrencieMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CurrencieMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CurrencieMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Currencie nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CurrencieMutation) ResetField(name string) error {
	switch name {
	case currencie.FieldName:
		m.ResetName()
		return nil
	case currencie.FieldSymbol:
		m.ResetSymbol()
		return nil
	case currencie.FieldThousandsSeparator:
		m.ResetThousandsSeparator()
		return nil
	case currencie.FieldUnitsSeparator:
		m.ResetUnitsSeparator()
		return nil
	case currencie.FieldSymbolPosition:
		m.ResetSymbolPosition()
		return nil
	case currencie.FieldDenominator:
		m.ResetDenominator()
		return nil
	}
	return fmt.Errorf("unknown Currencie field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CurrencieMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.currency_versions != nil {
		edges = append(edges, currencie.EdgeCurrencyVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CurrencieMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case currencie.EdgeCurrencyVersions:
		ids := make([]ent.Value, 0, len(m.currency_versions))
		for id := range m.currency_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CurrencieMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcurrency_versions != nil {
		edges = append(edges, currencie.EdgeCurrencyVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CurrencieMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case currencie.EdgeCurrencyVersions:
		ids := make([]ent.Value, 0, len(m.removedcurrency_versions))
		for id := range m.removedcurrency_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CurrencieMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcurrency_versions {
		edges = append(edges, currencie.EdgeCurrencyVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CurrencieMutation) EdgeCleared(name string) bool {
	switch name {
	case currencie.EdgeCurrencyVersions:
		return m.clearedcurrency_versions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CurrencieMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Currencie unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CurrencieMutation) ResetEdge(name string) error {
	switch name {
	case currencie.EdgeCurrencyVersions:
		m.ResetCurrencyVersions()
		return nil
	}
	return fmt.Errorf("unknown Currencie edge %s", name)
}

// CurrencyVersionMutation represents an operation that mutates the CurrencyVersion nodes in the graph.
type CurrencyVersionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	name                        *string
	min_bet                     *int
	addmin_bet                  *int
	max_exp                     *int
	addmax_exp                  *int
	denominator                 *int
	adddenominator              *int
	currency_id                 *int
	addcurrency_id              *int
	default_multiplier          *int
	adddefault_multiplier       *int
	deprecated                  *bool
	crash_bet_increment         *int
	addcrash_bet_increment      *int
	slots_bet_multipliers       *[]int
	appendslots_bet_multipliers []int
	clearedFields               map[string]struct{}
	_Currencie                  *int
	cleared_Currencie           bool
	game_types                  *int
	clearedgame_types           bool
	sessions                    map[int]struct{}
	removedsessions             map[int]struct{}
	clearedsessions             bool
	game_configs                map[int]struct{}
	removedgame_configs         map[int]struct{}
	clearedgame_configs         bool
	done                        bool
	oldValue                    func(context.Context) (*CurrencyVersion, error)
	predicates                  []predicate.CurrencyVersion
}

var _ ent.Mutation = (*CurrencyVersionMutation)(nil)

// currencyversionOption allows management of the mutation configuration using functional options.
type currencyversionOption func(*CurrencyVersionMutation)

// newCurrencyVersionMutation creates new mutation for the CurrencyVersion entity.
func newCurrencyVersionMutation(c config, op Op, opts ...currencyversionOption) *CurrencyVersionMutation {
	m := &CurrencyVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeCurrencyVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCurrencyVersionID sets the ID field of the mutation.
func withCurrencyVersionID(id int) currencyversionOption {
	return func(m *CurrencyVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *CurrencyVersion
		)
		m.oldValue = func(ctx context.Context) (*CurrencyVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CurrencyVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCurrencyVersion sets the old CurrencyVersion of the mutation.
func withCurrencyVersion(node *CurrencyVersion) currencyversionOption {
	return func(m *CurrencyVersionMutation) {
		m.oldValue = func(context.Context) (*CurrencyVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CurrencyVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CurrencyVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CurrencyVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CurrencyVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CurrencyVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CurrencyVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CurrencyVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CurrencyVersionMutation) ResetName() {
	m.name = nil
}

// SetMinBet sets the "min_bet" field.
func (m *CurrencyVersionMutation) SetMinBet(i int) {
	m.min_bet = &i
	m.addmin_bet = nil
}

// MinBet returns the value of the "min_bet" field in the mutation.
func (m *CurrencyVersionMutation) MinBet() (r int, exists bool) {
	v := m.min_bet
	if v == nil {
		return
	}
	return *v, true
}

// OldMinBet returns the old "min_bet" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldMinBet(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinBet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinBet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinBet: %w", err)
	}
	return oldValue.MinBet, nil
}

// AddMinBet adds i to the "min_bet" field.
func (m *CurrencyVersionMutation) AddMinBet(i int) {
	if m.addmin_bet != nil {
		*m.addmin_bet += i
	} else {
		m.addmin_bet = &i
	}
}

// AddedMinBet returns the value that was added to the "min_bet" field in this mutation.
func (m *CurrencyVersionMutation) AddedMinBet() (r int, exists bool) {
	v := m.addmin_bet
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinBet resets all changes to the "min_bet" field.
func (m *CurrencyVersionMutation) ResetMinBet() {
	m.min_bet = nil
	m.addmin_bet = nil
}

// SetMaxExp sets the "max_exp" field.
func (m *CurrencyVersionMutation) SetMaxExp(i int) {
	m.max_exp = &i
	m.addmax_exp = nil
}

// MaxExp returns the value of the "max_exp" field in the mutation.
func (m *CurrencyVersionMutation) MaxExp() (r int, exists bool) {
	v := m.max_exp
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxExp returns the old "max_exp" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldMaxExp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxExp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxExp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxExp: %w", err)
	}
	return oldValue.MaxExp, nil
}

// AddMaxExp adds i to the "max_exp" field.
func (m *CurrencyVersionMutation) AddMaxExp(i int) {
	if m.addmax_exp != nil {
		*m.addmax_exp += i
	} else {
		m.addmax_exp = &i
	}
}

// AddedMaxExp returns the value that was added to the "max_exp" field in this mutation.
func (m *CurrencyVersionMutation) AddedMaxExp() (r int, exists bool) {
	v := m.addmax_exp
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxExp resets all changes to the "max_exp" field.
func (m *CurrencyVersionMutation) ResetMaxExp() {
	m.max_exp = nil
	m.addmax_exp = nil
}

// SetDenominator sets the "denominator" field.
func (m *CurrencyVersionMutation) SetDenominator(i int) {
	m.denominator = &i
	m.adddenominator = nil
}

// Denominator returns the value of the "denominator" field in the mutation.
func (m *CurrencyVersionMutation) Denominator() (r int, exists bool) {
	v := m.denominator
	if v == nil {
		return
	}
	return *v, true
}

// OldDenominator returns the old "denominator" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldDenominator(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenominator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenominator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenominator: %w", err)
	}
	return oldValue.Denominator, nil
}

// AddDenominator adds i to the "denominator" field.
func (m *CurrencyVersionMutation) AddDenominator(i int) {
	if m.adddenominator != nil {
		*m.adddenominator += i
	} else {
		m.adddenominator = &i
	}
}

// AddedDenominator returns the value that was added to the "denominator" field in this mutation.
func (m *CurrencyVersionMutation) AddedDenominator() (r int, exists bool) {
	v := m.adddenominator
	if v == nil {
		return
	}
	return *v, true
}

// ResetDenominator resets all changes to the "denominator" field.
func (m *CurrencyVersionMutation) ResetDenominator() {
	m.denominator = nil
	m.adddenominator = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *CurrencyVersionMutation) SetCurrencyID(i int) {
	m.currency_id = &i
	m.addcurrency_id = nil
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *CurrencyVersionMutation) CurrencyID() (r int, exists bool) {
	v := m.currency_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// AddCurrencyID adds i to the "currency_id" field.
func (m *CurrencyVersionMutation) AddCurrencyID(i int) {
	if m.addcurrency_id != nil {
		*m.addcurrency_id += i
	} else {
		m.addcurrency_id = &i
	}
}

// AddedCurrencyID returns the value that was added to the "currency_id" field in this mutation.
func (m *CurrencyVersionMutation) AddedCurrencyID() (r int, exists bool) {
	v := m.addcurrency_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *CurrencyVersionMutation) ResetCurrencyID() {
	m.currency_id = nil
	m.addcurrency_id = nil
}

// SetDefaultMultiplier sets the "default_multiplier" field.
func (m *CurrencyVersionMutation) SetDefaultMultiplier(i int) {
	m.default_multiplier = &i
	m.adddefault_multiplier = nil
}

// DefaultMultiplier returns the value of the "default_multiplier" field in the mutation.
func (m *CurrencyVersionMutation) DefaultMultiplier() (r int, exists bool) {
	v := m.default_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultMultiplier returns the old "default_multiplier" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldDefaultMultiplier(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultMultiplier: %w", err)
	}
	return oldValue.DefaultMultiplier, nil
}

// AddDefaultMultiplier adds i to the "default_multiplier" field.
func (m *CurrencyVersionMutation) AddDefaultMultiplier(i int) {
	if m.adddefault_multiplier != nil {
		*m.adddefault_multiplier += i
	} else {
		m.adddefault_multiplier = &i
	}
}

// AddedDefaultMultiplier returns the value that was added to the "default_multiplier" field in this mutation.
func (m *CurrencyVersionMutation) AddedDefaultMultiplier() (r int, exists bool) {
	v := m.adddefault_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultMultiplier resets all changes to the "default_multiplier" field.
func (m *CurrencyVersionMutation) ResetDefaultMultiplier() {
	m.default_multiplier = nil
	m.adddefault_multiplier = nil
}

// SetDeprecated sets the "deprecated" field.
func (m *CurrencyVersionMutation) SetDeprecated(b bool) {
	m.deprecated = &b
}

// Deprecated returns the value of the "deprecated" field in the mutation.
func (m *CurrencyVersionMutation) Deprecated() (r bool, exists bool) {
	v := m.deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeprecated returns the old "deprecated" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeprecated: %w", err)
	}
	return oldValue.Deprecated, nil
}

// ResetDeprecated resets all changes to the "deprecated" field.
func (m *CurrencyVersionMutation) ResetDeprecated() {
	m.deprecated = nil
}

// SetCrashBetIncrement sets the "crash_bet_increment" field.
func (m *CurrencyVersionMutation) SetCrashBetIncrement(i int) {
	m.crash_bet_increment = &i
	m.addcrash_bet_increment = nil
}

// CrashBetIncrement returns the value of the "crash_bet_increment" field in the mutation.
func (m *CurrencyVersionMutation) CrashBetIncrement() (r int, exists bool) {
	v := m.crash_bet_increment
	if v == nil {
		return
	}
	return *v, true
}

// OldCrashBetIncrement returns the old "crash_bet_increment" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldCrashBetIncrement(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrashBetIncrement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrashBetIncrement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrashBetIncrement: %w", err)
	}
	return oldValue.CrashBetIncrement, nil
}

// AddCrashBetIncrement adds i to the "crash_bet_increment" field.
func (m *CurrencyVersionMutation) AddCrashBetIncrement(i int) {
	if m.addcrash_bet_increment != nil {
		*m.addcrash_bet_increment += i
	} else {
		m.addcrash_bet_increment = &i
	}
}

// AddedCrashBetIncrement returns the value that was added to the "crash_bet_increment" field in this mutation.
func (m *CurrencyVersionMutation) AddedCrashBetIncrement() (r int, exists bool) {
	v := m.addcrash_bet_increment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCrashBetIncrement resets all changes to the "crash_bet_increment" field.
func (m *CurrencyVersionMutation) ResetCrashBetIncrement() {
	m.crash_bet_increment = nil
	m.addcrash_bet_increment = nil
}

// SetSlotsBetMultipliers sets the "slots_bet_multipliers" field.
func (m *CurrencyVersionMutation) SetSlotsBetMultipliers(i []int) {
	m.slots_bet_multipliers = &i
	m.appendslots_bet_multipliers = nil
}

// SlotsBetMultipliers returns the value of the "slots_bet_multipliers" field in the mutation.
func (m *CurrencyVersionMutation) SlotsBetMultipliers() (r []int, exists bool) {
	v := m.slots_bet_multipliers
	if v == nil {
		return
	}
	return *v, true
}

// OldSlotsBetMultipliers returns the old "slots_bet_multipliers" field's value of the CurrencyVersion entity.
// If the CurrencyVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyVersionMutation) OldSlotsBetMultipliers(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlotsBetMultipliers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlotsBetMultipliers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlotsBetMultipliers: %w", err)
	}
	return oldValue.SlotsBetMultipliers, nil
}

// AppendSlotsBetMultipliers adds i to the "slots_bet_multipliers" field.
func (m *CurrencyVersionMutation) AppendSlotsBetMultipliers(i []int) {
	m.appendslots_bet_multipliers = append(m.appendslots_bet_multipliers, i...)
}

// AppendedSlotsBetMultipliers returns the list of values that were appended to the "slots_bet_multipliers" field in this mutation.
func (m *CurrencyVersionMutation) AppendedSlotsBetMultipliers() ([]int, bool) {
	if len(m.appendslots_bet_multipliers) == 0 {
		return nil, false
	}
	return m.appendslots_bet_multipliers, true
}

// ResetSlotsBetMultipliers resets all changes to the "slots_bet_multipliers" field.
func (m *CurrencyVersionMutation) ResetSlotsBetMultipliers() {
	m.slots_bet_multipliers = nil
	m.appendslots_bet_multipliers = nil
}

// SetCurrencieID sets the "Currencie" edge to the Currencie entity by id.
func (m *CurrencyVersionMutation) SetCurrencieID(id int) {
	m._Currencie = &id
}

// ClearCurrencie clears the "Currencie" edge to the Currencie entity.
func (m *CurrencyVersionMutation) ClearCurrencie() {
	m.cleared_Currencie = true
}

// CurrencieCleared reports if the "Currencie" edge to the Currencie entity was cleared.
func (m *CurrencyVersionMutation) CurrencieCleared() bool {
	return m.cleared_Currencie
}

// CurrencieID returns the "Currencie" edge ID in the mutation.
func (m *CurrencyVersionMutation) CurrencieID() (id int, exists bool) {
	if m._Currencie != nil {
		return *m._Currencie, true
	}
	return
}

// CurrencieIDs returns the "Currencie" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencieID instead. It exists only for internal usage by the builders.
func (m *CurrencyVersionMutation) CurrencieIDs() (ids []int) {
	if id := m._Currencie; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrencie resets all changes to the "Currencie" edge.
func (m *CurrencyVersionMutation) ResetCurrencie() {
	m._Currencie = nil
	m.cleared_Currencie = false
}

// SetGameTypesID sets the "game_types" edge to the GameType entity by id.
func (m *CurrencyVersionMutation) SetGameTypesID(id int) {
	m.game_types = &id
}

// ClearGameTypes clears the "game_types" edge to the GameType entity.
func (m *CurrencyVersionMutation) ClearGameTypes() {
	m.clearedgame_types = true
}

// GameTypesCleared reports if the "game_types" edge to the GameType entity was cleared.
func (m *CurrencyVersionMutation) GameTypesCleared() bool {
	return m.clearedgame_types
}

// GameTypesID returns the "game_types" edge ID in the mutation.
func (m *CurrencyVersionMutation) GameTypesID() (id int, exists bool) {
	if m.game_types != nil {
		return *m.game_types, true
	}
	return
}

// GameTypesIDs returns the "game_types" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameTypesID instead. It exists only for internal usage by the builders.
func (m *CurrencyVersionMutation) GameTypesIDs() (ids []int) {
	if id := m.game_types; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGameTypes resets all changes to the "game_types" edge.
func (m *CurrencyVersionMutation) ResetGameTypes() {
	m.game_types = nil
	m.clearedgame_types = false
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *CurrencyVersionMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *CurrencyVersionMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *CurrencyVersionMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *CurrencyVersionMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *CurrencyVersionMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *CurrencyVersionMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *CurrencyVersionMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by ids.
func (m *CurrencyVersionMutation) AddGameConfigIDs(ids ...int) {
	if m.game_configs == nil {
		m.game_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.game_configs[ids[i]] = struct{}{}
	}
}

// ClearGameConfigs clears the "game_configs" edge to the GameConfig entity.
func (m *CurrencyVersionMutation) ClearGameConfigs() {
	m.clearedgame_configs = true
}

// GameConfigsCleared reports if the "game_configs" edge to the GameConfig entity was cleared.
func (m *CurrencyVersionMutation) GameConfigsCleared() bool {
	return m.clearedgame_configs
}

// RemoveGameConfigIDs removes the "game_configs" edge to the GameConfig entity by IDs.
func (m *CurrencyVersionMutation) RemoveGameConfigIDs(ids ...int) {
	if m.removedgame_configs == nil {
		m.removedgame_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_configs, ids[i])
		m.removedgame_configs[ids[i]] = struct{}{}
	}
}

// RemovedGameConfigs returns the removed IDs of the "game_configs" edge to the GameConfig entity.
func (m *CurrencyVersionMutation) RemovedGameConfigsIDs() (ids []int) {
	for id := range m.removedgame_configs {
		ids = append(ids, id)
	}
	return
}

// GameConfigsIDs returns the "game_configs" edge IDs in the mutation.
func (m *CurrencyVersionMutation) GameConfigsIDs() (ids []int) {
	for id := range m.game_configs {
		ids = append(ids, id)
	}
	return
}

// ResetGameConfigs resets all changes to the "game_configs" edge.
func (m *CurrencyVersionMutation) ResetGameConfigs() {
	m.game_configs = nil
	m.clearedgame_configs = false
	m.removedgame_configs = nil
}

// Where appends a list predicates to the CurrencyVersionMutation builder.
func (m *CurrencyVersionMutation) Where(ps ...predicate.CurrencyVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CurrencyVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CurrencyVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CurrencyVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CurrencyVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CurrencyVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CurrencyVersion).
func (m *CurrencyVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CurrencyVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, currencyversion.FieldName)
	}
	if m.min_bet != nil {
		fields = append(fields, currencyversion.FieldMinBet)
	}
	if m.max_exp != nil {
		fields = append(fields, currencyversion.FieldMaxExp)
	}
	if m.denominator != nil {
		fields = append(fields, currencyversion.FieldDenominator)
	}
	if m.currency_id != nil {
		fields = append(fields, currencyversion.FieldCurrencyID)
	}
	if m.default_multiplier != nil {
		fields = append(fields, currencyversion.FieldDefaultMultiplier)
	}
	if m.deprecated != nil {
		fields = append(fields, currencyversion.FieldDeprecated)
	}
	if m.crash_bet_increment != nil {
		fields = append(fields, currencyversion.FieldCrashBetIncrement)
	}
	if m.slots_bet_multipliers != nil {
		fields = append(fields, currencyversion.FieldSlotsBetMultipliers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CurrencyVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case currencyversion.FieldName:
		return m.Name()
	case currencyversion.FieldMinBet:
		return m.MinBet()
	case currencyversion.FieldMaxExp:
		return m.MaxExp()
	case currencyversion.FieldDenominator:
		return m.Denominator()
	case currencyversion.FieldCurrencyID:
		return m.CurrencyID()
	case currencyversion.FieldDefaultMultiplier:
		return m.DefaultMultiplier()
	case currencyversion.FieldDeprecated:
		return m.Deprecated()
	case currencyversion.FieldCrashBetIncrement:
		return m.CrashBetIncrement()
	case currencyversion.FieldSlotsBetMultipliers:
		return m.SlotsBetMultipliers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CurrencyVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case currencyversion.FieldName:
		return m.OldName(ctx)
	case currencyversion.FieldMinBet:
		return m.OldMinBet(ctx)
	case currencyversion.FieldMaxExp:
		return m.OldMaxExp(ctx)
	case currencyversion.FieldDenominator:
		return m.OldDenominator(ctx)
	case currencyversion.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	case currencyversion.FieldDefaultMultiplier:
		return m.OldDefaultMultiplier(ctx)
	case currencyversion.FieldDeprecated:
		return m.OldDeprecated(ctx)
	case currencyversion.FieldCrashBetIncrement:
		return m.OldCrashBetIncrement(ctx)
	case currencyversion.FieldSlotsBetMultipliers:
		return m.OldSlotsBetMultipliers(ctx)
	}
	return nil, fmt.Errorf("unknown CurrencyVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case currencyversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case currencyversion.FieldMinBet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinBet(v)
		return nil
	case currencyversion.FieldMaxExp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxExp(v)
		return nil
	case currencyversion.FieldDenominator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenominator(v)
		return nil
	case currencyversion.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	case currencyversion.FieldDefaultMultiplier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultMultiplier(v)
		return nil
	case currencyversion.FieldDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeprecated(v)
		return nil
	case currencyversion.FieldCrashBetIncrement:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrashBetIncrement(v)
		return nil
	case currencyversion.FieldSlotsBetMultipliers:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlotsBetMultipliers(v)
		return nil
	}
	return fmt.Errorf("unknown CurrencyVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CurrencyVersionMutation) AddedFields() []string {
	var fields []string
	if m.addmin_bet != nil {
		fields = append(fields, currencyversion.FieldMinBet)
	}
	if m.addmax_exp != nil {
		fields = append(fields, currencyversion.FieldMaxExp)
	}
	if m.adddenominator != nil {
		fields = append(fields, currencyversion.FieldDenominator)
	}
	if m.addcurrency_id != nil {
		fields = append(fields, currencyversion.FieldCurrencyID)
	}
	if m.adddefault_multiplier != nil {
		fields = append(fields, currencyversion.FieldDefaultMultiplier)
	}
	if m.addcrash_bet_increment != nil {
		fields = append(fields, currencyversion.FieldCrashBetIncrement)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CurrencyVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case currencyversion.FieldMinBet:
		return m.AddedMinBet()
	case currencyversion.FieldMaxExp:
		return m.AddedMaxExp()
	case currencyversion.FieldDenominator:
		return m.AddedDenominator()
	case currencyversion.FieldCurrencyID:
		return m.AddedCurrencyID()
	case currencyversion.FieldDefaultMultiplier:
		return m.AddedDefaultMultiplier()
	case currencyversion.FieldCrashBetIncrement:
		return m.AddedCrashBetIncrement()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case currencyversion.FieldMinBet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinBet(v)
		return nil
	case currencyversion.FieldMaxExp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxExp(v)
		return nil
	case currencyversion.FieldDenominator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDenominator(v)
		return nil
	case currencyversion.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrencyID(v)
		return nil
	case currencyversion.FieldDefaultMultiplier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultMultiplier(v)
		return nil
	case currencyversion.FieldCrashBetIncrement:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCrashBetIncrement(v)
		return nil
	}
	return fmt.Errorf("unknown CurrencyVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CurrencyVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CurrencyVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CurrencyVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CurrencyVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CurrencyVersionMutation) ResetField(name string) error {
	switch name {
	case currencyversion.FieldName:
		m.ResetName()
		return nil
	case currencyversion.FieldMinBet:
		m.ResetMinBet()
		return nil
	case currencyversion.FieldMaxExp:
		m.ResetMaxExp()
		return nil
	case currencyversion.FieldDenominator:
		m.ResetDenominator()
		return nil
	case currencyversion.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	case currencyversion.FieldDefaultMultiplier:
		m.ResetDefaultMultiplier()
		return nil
	case currencyversion.FieldDeprecated:
		m.ResetDeprecated()
		return nil
	case currencyversion.FieldCrashBetIncrement:
		m.ResetCrashBetIncrement()
		return nil
	case currencyversion.FieldSlotsBetMultipliers:
		m.ResetSlotsBetMultipliers()
		return nil
	}
	return fmt.Errorf("unknown CurrencyVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CurrencyVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Currencie != nil {
		edges = append(edges, currencyversion.EdgeCurrencie)
	}
	if m.game_types != nil {
		edges = append(edges, currencyversion.EdgeGameTypes)
	}
	if m.sessions != nil {
		edges = append(edges, currencyversion.EdgeSessions)
	}
	if m.game_configs != nil {
		edges = append(edges, currencyversion.EdgeGameConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CurrencyVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case currencyversion.EdgeCurrencie:
		if id := m._Currencie; id != nil {
			return []ent.Value{*id}
		}
	case currencyversion.EdgeGameTypes:
		if id := m.game_types; id != nil {
			return []ent.Value{*id}
		}
	case currencyversion.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case currencyversion.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.game_configs))
		for id := range m.game_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CurrencyVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsessions != nil {
		edges = append(edges, currencyversion.EdgeSessions)
	}
	if m.removedgame_configs != nil {
		edges = append(edges, currencyversion.EdgeGameConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CurrencyVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case currencyversion.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case currencyversion.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.removedgame_configs))
		for id := range m.removedgame_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CurrencyVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Currencie {
		edges = append(edges, currencyversion.EdgeCurrencie)
	}
	if m.clearedgame_types {
		edges = append(edges, currencyversion.EdgeGameTypes)
	}
	if m.clearedsessions {
		edges = append(edges, currencyversion.EdgeSessions)
	}
	if m.clearedgame_configs {
		edges = append(edges, currencyversion.EdgeGameConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CurrencyVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case currencyversion.EdgeCurrencie:
		return m.cleared_Currencie
	case currencyversion.EdgeGameTypes:
		return m.clearedgame_types
	case currencyversion.EdgeSessions:
		return m.clearedsessions
	case currencyversion.EdgeGameConfigs:
		return m.clearedgame_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CurrencyVersionMutation) ClearEdge(name string) error {
	switch name {
	case currencyversion.EdgeCurrencie:
		m.ClearCurrencie()
		return nil
	case currencyversion.EdgeGameTypes:
		m.ClearGameTypes()
		return nil
	}
	return fmt.Errorf("unknown CurrencyVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CurrencyVersionMutation) ResetEdge(name string) error {
	switch name {
	case currencyversion.EdgeCurrencie:
		m.ResetCurrencie()
		return nil
	case currencyversion.EdgeGameTypes:
		m.ResetGameTypes()
		return nil
	case currencyversion.EdgeSessions:
		m.ResetSessions()
		return nil
	case currencyversion.EdgeGameConfigs:
		m.ResetGameConfigs()
		return nil
	}
	return fmt.Errorf("unknown CurrencyVersion edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	external_id           *string
	clearedFields         map[string]struct{}
	game_features         map[int]struct{}
	removedgame_features  map[int]struct{}
	clearedgame_features  bool
	serie_features        map[int]struct{}
	removedserie_features map[int]struct{}
	clearedserie_features bool
	done                  bool
	oldValue              func(context.Context) (*Feature, error)
	predicates            []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id int) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the "external_id" field.
func (m *FeatureMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *FeatureMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *FeatureMutation) ResetExternalID() {
	m.external_id = nil
}

// AddGameFeatureIDs adds the "game_features" edge to the GameFeature entity by ids.
func (m *FeatureMutation) AddGameFeatureIDs(ids ...int) {
	if m.game_features == nil {
		m.game_features = make(map[int]struct{})
	}
	for i := range ids {
		m.game_features[ids[i]] = struct{}{}
	}
}

// ClearGameFeatures clears the "game_features" edge to the GameFeature entity.
func (m *FeatureMutation) ClearGameFeatures() {
	m.clearedgame_features = true
}

// GameFeaturesCleared reports if the "game_features" edge to the GameFeature entity was cleared.
func (m *FeatureMutation) GameFeaturesCleared() bool {
	return m.clearedgame_features
}

// RemoveGameFeatureIDs removes the "game_features" edge to the GameFeature entity by IDs.
func (m *FeatureMutation) RemoveGameFeatureIDs(ids ...int) {
	if m.removedgame_features == nil {
		m.removedgame_features = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_features, ids[i])
		m.removedgame_features[ids[i]] = struct{}{}
	}
}

// RemovedGameFeatures returns the removed IDs of the "game_features" edge to the GameFeature entity.
func (m *FeatureMutation) RemovedGameFeaturesIDs() (ids []int) {
	for id := range m.removedgame_features {
		ids = append(ids, id)
	}
	return
}

// GameFeaturesIDs returns the "game_features" edge IDs in the mutation.
func (m *FeatureMutation) GameFeaturesIDs() (ids []int) {
	for id := range m.game_features {
		ids = append(ids, id)
	}
	return
}

// ResetGameFeatures resets all changes to the "game_features" edge.
func (m *FeatureMutation) ResetGameFeatures() {
	m.game_features = nil
	m.clearedgame_features = false
	m.removedgame_features = nil
}

// AddSerieFeatureIDs adds the "serie_features" edge to the SerieFeature entity by ids.
func (m *FeatureMutation) AddSerieFeatureIDs(ids ...int) {
	if m.serie_features == nil {
		m.serie_features = make(map[int]struct{})
	}
	for i := range ids {
		m.serie_features[ids[i]] = struct{}{}
	}
}

// ClearSerieFeatures clears the "serie_features" edge to the SerieFeature entity.
func (m *FeatureMutation) ClearSerieFeatures() {
	m.clearedserie_features = true
}

// SerieFeaturesCleared reports if the "serie_features" edge to the SerieFeature entity was cleared.
func (m *FeatureMutation) SerieFeaturesCleared() bool {
	return m.clearedserie_features
}

// RemoveSerieFeatureIDs removes the "serie_features" edge to the SerieFeature entity by IDs.
func (m *FeatureMutation) RemoveSerieFeatureIDs(ids ...int) {
	if m.removedserie_features == nil {
		m.removedserie_features = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.serie_features, ids[i])
		m.removedserie_features[ids[i]] = struct{}{}
	}
}

// RemovedSerieFeatures returns the removed IDs of the "serie_features" edge to the SerieFeature entity.
func (m *FeatureMutation) RemovedSerieFeaturesIDs() (ids []int) {
	for id := range m.removedserie_features {
		ids = append(ids, id)
	}
	return
}

// SerieFeaturesIDs returns the "serie_features" edge IDs in the mutation.
func (m *FeatureMutation) SerieFeaturesIDs() (ids []int) {
	for id := range m.serie_features {
		ids = append(ids, id)
	}
	return
}

// ResetSerieFeatures resets all changes to the "serie_features" edge.
func (m *FeatureMutation) ResetSerieFeatures() {
	m.serie_features = nil
	m.clearedserie_features = false
	m.removedserie_features = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, feature.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldName:
		return m.Name()
	case feature.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.game_features != nil {
		edges = append(edges, feature.EdgeGameFeatures)
	}
	if m.serie_features != nil {
		edges = append(edges, feature.EdgeSerieFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeGameFeatures:
		ids := make([]ent.Value, 0, len(m.game_features))
		for id := range m.game_features {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeSerieFeatures:
		ids := make([]ent.Value, 0, len(m.serie_features))
		for id := range m.serie_features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgame_features != nil {
		edges = append(edges, feature.EdgeGameFeatures)
	}
	if m.removedserie_features != nil {
		edges = append(edges, feature.EdgeSerieFeatures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeGameFeatures:
		ids := make([]ent.Value, 0, len(m.removedgame_features))
		for id := range m.removedgame_features {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeSerieFeatures:
		ids := make([]ent.Value, 0, len(m.removedserie_features))
		for id := range m.removedserie_features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgame_features {
		edges = append(edges, feature.EdgeGameFeatures)
	}
	if m.clearedserie_features {
		edges = append(edges, feature.EdgeSerieFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeGameFeatures:
		return m.clearedgame_features
	case feature.EdgeSerieFeatures:
		return m.clearedserie_features
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeGameFeatures:
		m.ResetGameFeatures()
		return nil
	case feature.EdgeSerieFeatures:
		m.ResetSerieFeatures()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// GameMutation represents an operation that mutates the Game nodes in the graph.
type GameMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	external_id          *string
	trademark_name       *string
	clearedFields        map[string]struct{}
	studio               *int
	clearedstudio        bool
	game_type            *int
	clearedgame_type     bool
	serie                *int
	clearedserie         bool
	game_features        map[int]struct{}
	removedgame_features map[int]struct{}
	clearedgame_features bool
	game_versions        map[int]struct{}
	removedgame_versions map[int]struct{}
	clearedgame_versions bool
	game_configs         map[int]struct{}
	removedgame_configs  map[int]struct{}
	clearedgame_configs  bool
	sessions             map[int]struct{}
	removedsessions      map[int]struct{}
	clearedsessions      bool
	done                 bool
	oldValue             func(context.Context) (*Game, error)
	predicates           []predicate.Game
}

var _ ent.Mutation = (*GameMutation)(nil)

// gameOption allows management of the mutation configuration using functional options.
type gameOption func(*GameMutation)

// newGameMutation creates new mutation for the Game entity.
func newGameMutation(c config, op Op, opts ...gameOption) *GameMutation {
	m := &GameMutation{
		config:        c,
		op:            op,
		typ:           TypeGame,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameID sets the ID field of the mutation.
func withGameID(id int) gameOption {
	return func(m *GameMutation) {
		var (
			err   error
			once  sync.Once
			value *Game
		)
		m.oldValue = func(ctx context.Context) (*Game, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Game.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGame sets the old Game of the mutation.
func withGame(node *Game) gameOption {
	return func(m *GameMutation) {
		m.oldValue = func(context.Context) (*Game, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Game.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GameMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the "external_id" field.
func (m *GameMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *GameMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *GameMutation) ResetExternalID() {
	m.external_id = nil
}

// SetTrademarkName sets the "trademark_name" field.
func (m *GameMutation) SetTrademarkName(s string) {
	m.trademark_name = &s
}

// TrademarkName returns the value of the "trademark_name" field in the mutation.
func (m *GameMutation) TrademarkName() (r string, exists bool) {
	v := m.trademark_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTrademarkName returns the old "trademark_name" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldTrademarkName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrademarkName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrademarkName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrademarkName: %w", err)
	}
	return oldValue.TrademarkName, nil
}

// ResetTrademarkName resets all changes to the "trademark_name" field.
func (m *GameMutation) ResetTrademarkName() {
	m.trademark_name = nil
}

// SetStudioID sets the "studio" edge to the Studio entity by id.
func (m *GameMutation) SetStudioID(id int) {
	m.studio = &id
}

// ClearStudio clears the "studio" edge to the Studio entity.
func (m *GameMutation) ClearStudio() {
	m.clearedstudio = true
}

// StudioCleared reports if the "studio" edge to the Studio entity was cleared.
func (m *GameMutation) StudioCleared() bool {
	return m.clearedstudio
}

// StudioID returns the "studio" edge ID in the mutation.
func (m *GameMutation) StudioID() (id int, exists bool) {
	if m.studio != nil {
		return *m.studio, true
	}
	return
}

// StudioIDs returns the "studio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudioID instead. It exists only for internal usage by the builders.
func (m *GameMutation) StudioIDs() (ids []int) {
	if id := m.studio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudio resets all changes to the "studio" edge.
func (m *GameMutation) ResetStudio() {
	m.studio = nil
	m.clearedstudio = false
}

// SetGameTypeID sets the "game_type" edge to the GameType entity by id.
func (m *GameMutation) SetGameTypeID(id int) {
	m.game_type = &id
}

// ClearGameType clears the "game_type" edge to the GameType entity.
func (m *GameMutation) ClearGameType() {
	m.clearedgame_type = true
}

// GameTypeCleared reports if the "game_type" edge to the GameType entity was cleared.
func (m *GameMutation) GameTypeCleared() bool {
	return m.clearedgame_type
}

// GameTypeID returns the "game_type" edge ID in the mutation.
func (m *GameMutation) GameTypeID() (id int, exists bool) {
	if m.game_type != nil {
		return *m.game_type, true
	}
	return
}

// GameTypeIDs returns the "game_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameTypeID instead. It exists only for internal usage by the builders.
func (m *GameMutation) GameTypeIDs() (ids []int) {
	if id := m.game_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGameType resets all changes to the "game_type" edge.
func (m *GameMutation) ResetGameType() {
	m.game_type = nil
	m.clearedgame_type = false
}

// SetSerieID sets the "serie" edge to the Serie entity by id.
func (m *GameMutation) SetSerieID(id int) {
	m.serie = &id
}

// ClearSerie clears the "serie" edge to the Serie entity.
func (m *GameMutation) ClearSerie() {
	m.clearedserie = true
}

// SerieCleared reports if the "serie" edge to the Serie entity was cleared.
func (m *GameMutation) SerieCleared() bool {
	return m.clearedserie
}

// SerieID returns the "serie" edge ID in the mutation.
func (m *GameMutation) SerieID() (id int, exists bool) {
	if m.serie != nil {
		return *m.serie, true
	}
	return
}

// SerieIDs returns the "serie" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SerieID instead. It exists only for internal usage by the builders.
func (m *GameMutation) SerieIDs() (ids []int) {
	if id := m.serie; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSerie resets all changes to the "serie" edge.
func (m *GameMutation) ResetSerie() {
	m.serie = nil
	m.clearedserie = false
}

// AddGameFeatureIDs adds the "game_features" edge to the GameFeature entity by ids.
func (m *GameMutation) AddGameFeatureIDs(ids ...int) {
	if m.game_features == nil {
		m.game_features = make(map[int]struct{})
	}
	for i := range ids {
		m.game_features[ids[i]] = struct{}{}
	}
}

// ClearGameFeatures clears the "game_features" edge to the GameFeature entity.
func (m *GameMutation) ClearGameFeatures() {
	m.clearedgame_features = true
}

// GameFeaturesCleared reports if the "game_features" edge to the GameFeature entity was cleared.
func (m *GameMutation) GameFeaturesCleared() bool {
	return m.clearedgame_features
}

// RemoveGameFeatureIDs removes the "game_features" edge to the GameFeature entity by IDs.
func (m *GameMutation) RemoveGameFeatureIDs(ids ...int) {
	if m.removedgame_features == nil {
		m.removedgame_features = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_features, ids[i])
		m.removedgame_features[ids[i]] = struct{}{}
	}
}

// RemovedGameFeatures returns the removed IDs of the "game_features" edge to the GameFeature entity.
func (m *GameMutation) RemovedGameFeaturesIDs() (ids []int) {
	for id := range m.removedgame_features {
		ids = append(ids, id)
	}
	return
}

// GameFeaturesIDs returns the "game_features" edge IDs in the mutation.
func (m *GameMutation) GameFeaturesIDs() (ids []int) {
	for id := range m.game_features {
		ids = append(ids, id)
	}
	return
}

// ResetGameFeatures resets all changes to the "game_features" edge.
func (m *GameMutation) ResetGameFeatures() {
	m.game_features = nil
	m.clearedgame_features = false
	m.removedgame_features = nil
}

// AddGameVersionIDs adds the "game_versions" edge to the GameVersion entity by ids.
func (m *GameMutation) AddGameVersionIDs(ids ...int) {
	if m.game_versions == nil {
		m.game_versions = make(map[int]struct{})
	}
	for i := range ids {
		m.game_versions[ids[i]] = struct{}{}
	}
}

// ClearGameVersions clears the "game_versions" edge to the GameVersion entity.
func (m *GameMutation) ClearGameVersions() {
	m.clearedgame_versions = true
}

// GameVersionsCleared reports if the "game_versions" edge to the GameVersion entity was cleared.
func (m *GameMutation) GameVersionsCleared() bool {
	return m.clearedgame_versions
}

// RemoveGameVersionIDs removes the "game_versions" edge to the GameVersion entity by IDs.
func (m *GameMutation) RemoveGameVersionIDs(ids ...int) {
	if m.removedgame_versions == nil {
		m.removedgame_versions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_versions, ids[i])
		m.removedgame_versions[ids[i]] = struct{}{}
	}
}

// RemovedGameVersions returns the removed IDs of the "game_versions" edge to the GameVersion entity.
func (m *GameMutation) RemovedGameVersionsIDs() (ids []int) {
	for id := range m.removedgame_versions {
		ids = append(ids, id)
	}
	return
}

// GameVersionsIDs returns the "game_versions" edge IDs in the mutation.
func (m *GameMutation) GameVersionsIDs() (ids []int) {
	for id := range m.game_versions {
		ids = append(ids, id)
	}
	return
}

// ResetGameVersions resets all changes to the "game_versions" edge.
func (m *GameMutation) ResetGameVersions() {
	m.game_versions = nil
	m.clearedgame_versions = false
	m.removedgame_versions = nil
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by ids.
func (m *GameMutation) AddGameConfigIDs(ids ...int) {
	if m.game_configs == nil {
		m.game_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.game_configs[ids[i]] = struct{}{}
	}
}

// ClearGameConfigs clears the "game_configs" edge to the GameConfig entity.
func (m *GameMutation) ClearGameConfigs() {
	m.clearedgame_configs = true
}

// GameConfigsCleared reports if the "game_configs" edge to the GameConfig entity was cleared.
func (m *GameMutation) GameConfigsCleared() bool {
	return m.clearedgame_configs
}

// RemoveGameConfigIDs removes the "game_configs" edge to the GameConfig entity by IDs.
func (m *GameMutation) RemoveGameConfigIDs(ids ...int) {
	if m.removedgame_configs == nil {
		m.removedgame_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_configs, ids[i])
		m.removedgame_configs[ids[i]] = struct{}{}
	}
}

// RemovedGameConfigs returns the removed IDs of the "game_configs" edge to the GameConfig entity.
func (m *GameMutation) RemovedGameConfigsIDs() (ids []int) {
	for id := range m.removedgame_configs {
		ids = append(ids, id)
	}
	return
}

// GameConfigsIDs returns the "game_configs" edge IDs in the mutation.
func (m *GameMutation) GameConfigsIDs() (ids []int) {
	for id := range m.game_configs {
		ids = append(ids, id)
	}
	return
}

// ResetGameConfigs resets all changes to the "game_configs" edge.
func (m *GameMutation) ResetGameConfigs() {
	m.game_configs = nil
	m.clearedgame_configs = false
	m.removedgame_configs = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *GameMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *GameMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *GameMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *GameMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *GameMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *GameMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *GameMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the GameMutation builder.
func (m *GameMutation) Where(ps ...predicate.Game) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Game, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Game).
func (m *GameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, game.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, game.FieldExternalID)
	}
	if m.trademark_name != nil {
		fields = append(fields, game.FieldTrademarkName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case game.FieldName:
		return m.Name()
	case game.FieldExternalID:
		return m.ExternalID()
	case game.FieldTrademarkName:
		return m.TrademarkName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case game.FieldName:
		return m.OldName(ctx)
	case game.FieldExternalID:
		return m.OldExternalID(ctx)
	case game.FieldTrademarkName:
		return m.OldTrademarkName(ctx)
	}
	return nil, fmt.Errorf("unknown Game field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case game.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case game.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case game.FieldTrademarkName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrademarkName(v)
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Game numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Game nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMutation) ResetField(name string) error {
	switch name {
	case game.FieldName:
		m.ResetName()
		return nil
	case game.FieldExternalID:
		m.ResetExternalID()
		return nil
	case game.FieldTrademarkName:
		m.ResetTrademarkName()
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.studio != nil {
		edges = append(edges, game.EdgeStudio)
	}
	if m.game_type != nil {
		edges = append(edges, game.EdgeGameType)
	}
	if m.serie != nil {
		edges = append(edges, game.EdgeSerie)
	}
	if m.game_features != nil {
		edges = append(edges, game.EdgeGameFeatures)
	}
	if m.game_versions != nil {
		edges = append(edges, game.EdgeGameVersions)
	}
	if m.game_configs != nil {
		edges = append(edges, game.EdgeGameConfigs)
	}
	if m.sessions != nil {
		edges = append(edges, game.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeStudio:
		if id := m.studio; id != nil {
			return []ent.Value{*id}
		}
	case game.EdgeGameType:
		if id := m.game_type; id != nil {
			return []ent.Value{*id}
		}
	case game.EdgeSerie:
		if id := m.serie; id != nil {
			return []ent.Value{*id}
		}
	case game.EdgeGameFeatures:
		ids := make([]ent.Value, 0, len(m.game_features))
		for id := range m.game_features {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeGameVersions:
		ids := make([]ent.Value, 0, len(m.game_versions))
		for id := range m.game_versions {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.game_configs))
		for id := range m.game_configs {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedgame_features != nil {
		edges = append(edges, game.EdgeGameFeatures)
	}
	if m.removedgame_versions != nil {
		edges = append(edges, game.EdgeGameVersions)
	}
	if m.removedgame_configs != nil {
		edges = append(edges, game.EdgeGameConfigs)
	}
	if m.removedsessions != nil {
		edges = append(edges, game.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeGameFeatures:
		ids := make([]ent.Value, 0, len(m.removedgame_features))
		for id := range m.removedgame_features {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeGameVersions:
		ids := make([]ent.Value, 0, len(m.removedgame_versions))
		for id := range m.removedgame_versions {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.removedgame_configs))
		for id := range m.removedgame_configs {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedstudio {
		edges = append(edges, game.EdgeStudio)
	}
	if m.clearedgame_type {
		edges = append(edges, game.EdgeGameType)
	}
	if m.clearedserie {
		edges = append(edges, game.EdgeSerie)
	}
	if m.clearedgame_features {
		edges = append(edges, game.EdgeGameFeatures)
	}
	if m.clearedgame_versions {
		edges = append(edges, game.EdgeGameVersions)
	}
	if m.clearedgame_configs {
		edges = append(edges, game.EdgeGameConfigs)
	}
	if m.clearedsessions {
		edges = append(edges, game.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMutation) EdgeCleared(name string) bool {
	switch name {
	case game.EdgeStudio:
		return m.clearedstudio
	case game.EdgeGameType:
		return m.clearedgame_type
	case game.EdgeSerie:
		return m.clearedserie
	case game.EdgeGameFeatures:
		return m.clearedgame_features
	case game.EdgeGameVersions:
		return m.clearedgame_versions
	case game.EdgeGameConfigs:
		return m.clearedgame_configs
	case game.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMutation) ClearEdge(name string) error {
	switch name {
	case game.EdgeStudio:
		m.ClearStudio()
		return nil
	case game.EdgeGameType:
		m.ClearGameType()
		return nil
	case game.EdgeSerie:
		m.ClearSerie()
		return nil
	}
	return fmt.Errorf("unknown Game unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMutation) ResetEdge(name string) error {
	switch name {
	case game.EdgeStudio:
		m.ResetStudio()
		return nil
	case game.EdgeGameType:
		m.ResetGameType()
		return nil
	case game.EdgeSerie:
		m.ResetSerie()
		return nil
	case game.EdgeGameFeatures:
		m.ResetGameFeatures()
		return nil
	case game.EdgeGameVersions:
		m.ResetGameVersions()
		return nil
	case game.EdgeGameConfigs:
		m.ResetGameConfigs()
		return nil
	case game.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown Game edge %s", name)
}

// GameConfigMutation represents an operation that mutates the GameConfig nodes in the graph.
type GameConfigMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	can_demo                 *bool
	can_tournament           *bool
	can_free_bets            *bool
	can_drop_and_wins        *bool
	can_turbo                *bool
	is_active                *bool
	can_auto_bet             *bool
	can_auto_cashout         *bool
	can_ante_bet             *bool
	can_home_button          *bool
	clearedFields            map[string]struct{}
	math_versions            *int
	clearedmath_versions     bool
	game_versions            *int
	clearedgame_versions     bool
	games                    *int
	clearedgames             bool
	_Operator                *int
	cleared_Operator         bool
	currency_versions        *int
	clearedcurrency_versions bool
	done                     bool
	oldValue                 func(context.Context) (*GameConfig, error)
	predicates               []predicate.GameConfig
}

var _ ent.Mutation = (*GameConfigMutation)(nil)

// gameconfigOption allows management of the mutation configuration using functional options.
type gameconfigOption func(*GameConfigMutation)

// newGameConfigMutation creates new mutation for the GameConfig entity.
func newGameConfigMutation(c config, op Op, opts ...gameconfigOption) *GameConfigMutation {
	m := &GameConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeGameConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameConfigID sets the ID field of the mutation.
func withGameConfigID(id int) gameconfigOption {
	return func(m *GameConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *GameConfig
		)
		m.oldValue = func(ctx context.Context) (*GameConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameConfig sets the old GameConfig of the mutation.
func withGameConfig(node *GameConfig) gameconfigOption {
	return func(m *GameConfigMutation) {
		m.oldValue = func(context.Context) (*GameConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCanDemo sets the "can_demo" field.
func (m *GameConfigMutation) SetCanDemo(b bool) {
	m.can_demo = &b
}

// CanDemo returns the value of the "can_demo" field in the mutation.
func (m *GameConfigMutation) CanDemo() (r bool, exists bool) {
	v := m.can_demo
	if v == nil {
		return
	}
	return *v, true
}

// OldCanDemo returns the old "can_demo" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanDemo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanDemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanDemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanDemo: %w", err)
	}
	return oldValue.CanDemo, nil
}

// ResetCanDemo resets all changes to the "can_demo" field.
func (m *GameConfigMutation) ResetCanDemo() {
	m.can_demo = nil
}

// SetCanTournament sets the "can_tournament" field.
func (m *GameConfigMutation) SetCanTournament(b bool) {
	m.can_tournament = &b
}

// CanTournament returns the value of the "can_tournament" field in the mutation.
func (m *GameConfigMutation) CanTournament() (r bool, exists bool) {
	v := m.can_tournament
	if v == nil {
		return
	}
	return *v, true
}

// OldCanTournament returns the old "can_tournament" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanTournament(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanTournament is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanTournament requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanTournament: %w", err)
	}
	return oldValue.CanTournament, nil
}

// ResetCanTournament resets all changes to the "can_tournament" field.
func (m *GameConfigMutation) ResetCanTournament() {
	m.can_tournament = nil
}

// SetCanFreeBets sets the "can_free_bets" field.
func (m *GameConfigMutation) SetCanFreeBets(b bool) {
	m.can_free_bets = &b
}

// CanFreeBets returns the value of the "can_free_bets" field in the mutation.
func (m *GameConfigMutation) CanFreeBets() (r bool, exists bool) {
	v := m.can_free_bets
	if v == nil {
		return
	}
	return *v, true
}

// OldCanFreeBets returns the old "can_free_bets" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanFreeBets(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanFreeBets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanFreeBets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanFreeBets: %w", err)
	}
	return oldValue.CanFreeBets, nil
}

// ResetCanFreeBets resets all changes to the "can_free_bets" field.
func (m *GameConfigMutation) ResetCanFreeBets() {
	m.can_free_bets = nil
}

// SetCanDropAndWins sets the "can_drop_and_wins" field.
func (m *GameConfigMutation) SetCanDropAndWins(b bool) {
	m.can_drop_and_wins = &b
}

// CanDropAndWins returns the value of the "can_drop_and_wins" field in the mutation.
func (m *GameConfigMutation) CanDropAndWins() (r bool, exists bool) {
	v := m.can_drop_and_wins
	if v == nil {
		return
	}
	return *v, true
}

// OldCanDropAndWins returns the old "can_drop_and_wins" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanDropAndWins(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanDropAndWins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanDropAndWins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanDropAndWins: %w", err)
	}
	return oldValue.CanDropAndWins, nil
}

// ResetCanDropAndWins resets all changes to the "can_drop_and_wins" field.
func (m *GameConfigMutation) ResetCanDropAndWins() {
	m.can_drop_and_wins = nil
}

// SetCanTurbo sets the "can_turbo" field.
func (m *GameConfigMutation) SetCanTurbo(b bool) {
	m.can_turbo = &b
}

// CanTurbo returns the value of the "can_turbo" field in the mutation.
func (m *GameConfigMutation) CanTurbo() (r bool, exists bool) {
	v := m.can_turbo
	if v == nil {
		return
	}
	return *v, true
}

// OldCanTurbo returns the old "can_turbo" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanTurbo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanTurbo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanTurbo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanTurbo: %w", err)
	}
	return oldValue.CanTurbo, nil
}

// ResetCanTurbo resets all changes to the "can_turbo" field.
func (m *GameConfigMutation) ResetCanTurbo() {
	m.can_turbo = nil
}

// SetIsActive sets the "is_active" field.
func (m *GameConfigMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *GameConfigMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *GameConfigMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCanAutoBet sets the "can_auto_bet" field.
func (m *GameConfigMutation) SetCanAutoBet(b bool) {
	m.can_auto_bet = &b
}

// CanAutoBet returns the value of the "can_auto_bet" field in the mutation.
func (m *GameConfigMutation) CanAutoBet() (r bool, exists bool) {
	v := m.can_auto_bet
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAutoBet returns the old "can_auto_bet" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanAutoBet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAutoBet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAutoBet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAutoBet: %w", err)
	}
	return oldValue.CanAutoBet, nil
}

// ResetCanAutoBet resets all changes to the "can_auto_bet" field.
func (m *GameConfigMutation) ResetCanAutoBet() {
	m.can_auto_bet = nil
}

// SetCanAutoCashout sets the "can_auto_cashout" field.
func (m *GameConfigMutation) SetCanAutoCashout(b bool) {
	m.can_auto_cashout = &b
}

// CanAutoCashout returns the value of the "can_auto_cashout" field in the mutation.
func (m *GameConfigMutation) CanAutoCashout() (r bool, exists bool) {
	v := m.can_auto_cashout
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAutoCashout returns the old "can_auto_cashout" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanAutoCashout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAutoCashout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAutoCashout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAutoCashout: %w", err)
	}
	return oldValue.CanAutoCashout, nil
}

// ResetCanAutoCashout resets all changes to the "can_auto_cashout" field.
func (m *GameConfigMutation) ResetCanAutoCashout() {
	m.can_auto_cashout = nil
}

// SetCanAnteBet sets the "can_ante_bet" field.
func (m *GameConfigMutation) SetCanAnteBet(b bool) {
	m.can_ante_bet = &b
}

// CanAnteBet returns the value of the "can_ante_bet" field in the mutation.
func (m *GameConfigMutation) CanAnteBet() (r bool, exists bool) {
	v := m.can_ante_bet
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAnteBet returns the old "can_ante_bet" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanAnteBet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAnteBet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAnteBet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAnteBet: %w", err)
	}
	return oldValue.CanAnteBet, nil
}

// ResetCanAnteBet resets all changes to the "can_ante_bet" field.
func (m *GameConfigMutation) ResetCanAnteBet() {
	m.can_ante_bet = nil
}

// SetCanHomeButton sets the "can_home_button" field.
func (m *GameConfigMutation) SetCanHomeButton(b bool) {
	m.can_home_button = &b
}

// CanHomeButton returns the value of the "can_home_button" field in the mutation.
func (m *GameConfigMutation) CanHomeButton() (r bool, exists bool) {
	v := m.can_home_button
	if v == nil {
		return
	}
	return *v, true
}

// OldCanHomeButton returns the old "can_home_button" field's value of the GameConfig entity.
// If the GameConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameConfigMutation) OldCanHomeButton(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanHomeButton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanHomeButton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanHomeButton: %w", err)
	}
	return oldValue.CanHomeButton, nil
}

// ResetCanHomeButton resets all changes to the "can_home_button" field.
func (m *GameConfigMutation) ResetCanHomeButton() {
	m.can_home_button = nil
}

// SetMathVersionsID sets the "math_versions" edge to the MathVersion entity by id.
func (m *GameConfigMutation) SetMathVersionsID(id int) {
	m.math_versions = &id
}

// ClearMathVersions clears the "math_versions" edge to the MathVersion entity.
func (m *GameConfigMutation) ClearMathVersions() {
	m.clearedmath_versions = true
}

// MathVersionsCleared reports if the "math_versions" edge to the MathVersion entity was cleared.
func (m *GameConfigMutation) MathVersionsCleared() bool {
	return m.clearedmath_versions
}

// MathVersionsID returns the "math_versions" edge ID in the mutation.
func (m *GameConfigMutation) MathVersionsID() (id int, exists bool) {
	if m.math_versions != nil {
		return *m.math_versions, true
	}
	return
}

// MathVersionsIDs returns the "math_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MathVersionsID instead. It exists only for internal usage by the builders.
func (m *GameConfigMutation) MathVersionsIDs() (ids []int) {
	if id := m.math_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMathVersions resets all changes to the "math_versions" edge.
func (m *GameConfigMutation) ResetMathVersions() {
	m.math_versions = nil
	m.clearedmath_versions = false
}

// SetGameVersionsID sets the "game_versions" edge to the GameVersion entity by id.
func (m *GameConfigMutation) SetGameVersionsID(id int) {
	m.game_versions = &id
}

// ClearGameVersions clears the "game_versions" edge to the GameVersion entity.
func (m *GameConfigMutation) ClearGameVersions() {
	m.clearedgame_versions = true
}

// GameVersionsCleared reports if the "game_versions" edge to the GameVersion entity was cleared.
func (m *GameConfigMutation) GameVersionsCleared() bool {
	return m.clearedgame_versions
}

// GameVersionsID returns the "game_versions" edge ID in the mutation.
func (m *GameConfigMutation) GameVersionsID() (id int, exists bool) {
	if m.game_versions != nil {
		return *m.game_versions, true
	}
	return
}

// GameVersionsIDs returns the "game_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameVersionsID instead. It exists only for internal usage by the builders.
func (m *GameConfigMutation) GameVersionsIDs() (ids []int) {
	if id := m.game_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGameVersions resets all changes to the "game_versions" edge.
func (m *GameConfigMutation) ResetGameVersions() {
	m.game_versions = nil
	m.clearedgame_versions = false
}

// SetGamesID sets the "games" edge to the Game entity by id.
func (m *GameConfigMutation) SetGamesID(id int) {
	m.games = &id
}

// ClearGames clears the "games" edge to the Game entity.
func (m *GameConfigMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *GameConfigMutation) GamesCleared() bool {
	return m.clearedgames
}

// GamesID returns the "games" edge ID in the mutation.
func (m *GameConfigMutation) GamesID() (id int, exists bool) {
	if m.games != nil {
		return *m.games, true
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GamesID instead. It exists only for internal usage by the builders.
func (m *GameConfigMutation) GamesIDs() (ids []int) {
	if id := m.games; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *GameConfigMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
}

// SetOperatorID sets the "Operator" edge to the Operator entity by id.
func (m *GameConfigMutation) SetOperatorID(id int) {
	m._Operator = &id
}

// ClearOperator clears the "Operator" edge to the Operator entity.
func (m *GameConfigMutation) ClearOperator() {
	m.cleared_Operator = true
}

// OperatorCleared reports if the "Operator" edge to the Operator entity was cleared.
func (m *GameConfigMutation) OperatorCleared() bool {
	return m.cleared_Operator
}

// OperatorID returns the "Operator" edge ID in the mutation.
func (m *GameConfigMutation) OperatorID() (id int, exists bool) {
	if m._Operator != nil {
		return *m._Operator, true
	}
	return
}

// OperatorIDs returns the "Operator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatorID instead. It exists only for internal usage by the builders.
func (m *GameConfigMutation) OperatorIDs() (ids []int) {
	if id := m._Operator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperator resets all changes to the "Operator" edge.
func (m *GameConfigMutation) ResetOperator() {
	m._Operator = nil
	m.cleared_Operator = false
}

// SetCurrencyVersionsID sets the "currency_versions" edge to the CurrencyVersion entity by id.
func (m *GameConfigMutation) SetCurrencyVersionsID(id int) {
	m.currency_versions = &id
}

// ClearCurrencyVersions clears the "currency_versions" edge to the CurrencyVersion entity.
func (m *GameConfigMutation) ClearCurrencyVersions() {
	m.clearedcurrency_versions = true
}

// CurrencyVersionsCleared reports if the "currency_versions" edge to the CurrencyVersion entity was cleared.
func (m *GameConfigMutation) CurrencyVersionsCleared() bool {
	return m.clearedcurrency_versions
}

// CurrencyVersionsID returns the "currency_versions" edge ID in the mutation.
func (m *GameConfigMutation) CurrencyVersionsID() (id int, exists bool) {
	if m.currency_versions != nil {
		return *m.currency_versions, true
	}
	return
}

// CurrencyVersionsIDs returns the "currency_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyVersionsID instead. It exists only for internal usage by the builders.
func (m *GameConfigMutation) CurrencyVersionsIDs() (ids []int) {
	if id := m.currency_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrencyVersions resets all changes to the "currency_versions" edge.
func (m *GameConfigMutation) ResetCurrencyVersions() {
	m.currency_versions = nil
	m.clearedcurrency_versions = false
}

// Where appends a list predicates to the GameConfigMutation builder.
func (m *GameConfigMutation) Where(ps ...predicate.GameConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameConfig).
func (m *GameConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameConfigMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.can_demo != nil {
		fields = append(fields, gameconfig.FieldCanDemo)
	}
	if m.can_tournament != nil {
		fields = append(fields, gameconfig.FieldCanTournament)
	}
	if m.can_free_bets != nil {
		fields = append(fields, gameconfig.FieldCanFreeBets)
	}
	if m.can_drop_and_wins != nil {
		fields = append(fields, gameconfig.FieldCanDropAndWins)
	}
	if m.can_turbo != nil {
		fields = append(fields, gameconfig.FieldCanTurbo)
	}
	if m.is_active != nil {
		fields = append(fields, gameconfig.FieldIsActive)
	}
	if m.can_auto_bet != nil {
		fields = append(fields, gameconfig.FieldCanAutoBet)
	}
	if m.can_auto_cashout != nil {
		fields = append(fields, gameconfig.FieldCanAutoCashout)
	}
	if m.can_ante_bet != nil {
		fields = append(fields, gameconfig.FieldCanAnteBet)
	}
	if m.can_home_button != nil {
		fields = append(fields, gameconfig.FieldCanHomeButton)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameconfig.FieldCanDemo:
		return m.CanDemo()
	case gameconfig.FieldCanTournament:
		return m.CanTournament()
	case gameconfig.FieldCanFreeBets:
		return m.CanFreeBets()
	case gameconfig.FieldCanDropAndWins:
		return m.CanDropAndWins()
	case gameconfig.FieldCanTurbo:
		return m.CanTurbo()
	case gameconfig.FieldIsActive:
		return m.IsActive()
	case gameconfig.FieldCanAutoBet:
		return m.CanAutoBet()
	case gameconfig.FieldCanAutoCashout:
		return m.CanAutoCashout()
	case gameconfig.FieldCanAnteBet:
		return m.CanAnteBet()
	case gameconfig.FieldCanHomeButton:
		return m.CanHomeButton()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameconfig.FieldCanDemo:
		return m.OldCanDemo(ctx)
	case gameconfig.FieldCanTournament:
		return m.OldCanTournament(ctx)
	case gameconfig.FieldCanFreeBets:
		return m.OldCanFreeBets(ctx)
	case gameconfig.FieldCanDropAndWins:
		return m.OldCanDropAndWins(ctx)
	case gameconfig.FieldCanTurbo:
		return m.OldCanTurbo(ctx)
	case gameconfig.FieldIsActive:
		return m.OldIsActive(ctx)
	case gameconfig.FieldCanAutoBet:
		return m.OldCanAutoBet(ctx)
	case gameconfig.FieldCanAutoCashout:
		return m.OldCanAutoCashout(ctx)
	case gameconfig.FieldCanAnteBet:
		return m.OldCanAnteBet(ctx)
	case gameconfig.FieldCanHomeButton:
		return m.OldCanHomeButton(ctx)
	}
	return nil, fmt.Errorf("unknown GameConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameconfig.FieldCanDemo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanDemo(v)
		return nil
	case gameconfig.FieldCanTournament:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanTournament(v)
		return nil
	case gameconfig.FieldCanFreeBets:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanFreeBets(v)
		return nil
	case gameconfig.FieldCanDropAndWins:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanDropAndWins(v)
		return nil
	case gameconfig.FieldCanTurbo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanTurbo(v)
		return nil
	case gameconfig.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case gameconfig.FieldCanAutoBet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAutoBet(v)
		return nil
	case gameconfig.FieldCanAutoCashout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAutoCashout(v)
		return nil
	case gameconfig.FieldCanAnteBet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAnteBet(v)
		return nil
	case gameconfig.FieldCanHomeButton:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanHomeButton(v)
		return nil
	}
	return fmt.Errorf("unknown GameConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameConfigMutation) ResetField(name string) error {
	switch name {
	case gameconfig.FieldCanDemo:
		m.ResetCanDemo()
		return nil
	case gameconfig.FieldCanTournament:
		m.ResetCanTournament()
		return nil
	case gameconfig.FieldCanFreeBets:
		m.ResetCanFreeBets()
		return nil
	case gameconfig.FieldCanDropAndWins:
		m.ResetCanDropAndWins()
		return nil
	case gameconfig.FieldCanTurbo:
		m.ResetCanTurbo()
		return nil
	case gameconfig.FieldIsActive:
		m.ResetIsActive()
		return nil
	case gameconfig.FieldCanAutoBet:
		m.ResetCanAutoBet()
		return nil
	case gameconfig.FieldCanAutoCashout:
		m.ResetCanAutoCashout()
		return nil
	case gameconfig.FieldCanAnteBet:
		m.ResetCanAnteBet()
		return nil
	case gameconfig.FieldCanHomeButton:
		m.ResetCanHomeButton()
		return nil
	}
	return fmt.Errorf("unknown GameConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.math_versions != nil {
		edges = append(edges, gameconfig.EdgeMathVersions)
	}
	if m.game_versions != nil {
		edges = append(edges, gameconfig.EdgeGameVersions)
	}
	if m.games != nil {
		edges = append(edges, gameconfig.EdgeGames)
	}
	if m._Operator != nil {
		edges = append(edges, gameconfig.EdgeOperator)
	}
	if m.currency_versions != nil {
		edges = append(edges, gameconfig.EdgeCurrencyVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameconfig.EdgeMathVersions:
		if id := m.math_versions; id != nil {
			return []ent.Value{*id}
		}
	case gameconfig.EdgeGameVersions:
		if id := m.game_versions; id != nil {
			return []ent.Value{*id}
		}
	case gameconfig.EdgeGames:
		if id := m.games; id != nil {
			return []ent.Value{*id}
		}
	case gameconfig.EdgeOperator:
		if id := m._Operator; id != nil {
			return []ent.Value{*id}
		}
	case gameconfig.EdgeCurrencyVersions:
		if id := m.currency_versions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmath_versions {
		edges = append(edges, gameconfig.EdgeMathVersions)
	}
	if m.clearedgame_versions {
		edges = append(edges, gameconfig.EdgeGameVersions)
	}
	if m.clearedgames {
		edges = append(edges, gameconfig.EdgeGames)
	}
	if m.cleared_Operator {
		edges = append(edges, gameconfig.EdgeOperator)
	}
	if m.clearedcurrency_versions {
		edges = append(edges, gameconfig.EdgeCurrencyVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case gameconfig.EdgeMathVersions:
		return m.clearedmath_versions
	case gameconfig.EdgeGameVersions:
		return m.clearedgame_versions
	case gameconfig.EdgeGames:
		return m.clearedgames
	case gameconfig.EdgeOperator:
		return m.cleared_Operator
	case gameconfig.EdgeCurrencyVersions:
		return m.clearedcurrency_versions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameConfigMutation) ClearEdge(name string) error {
	switch name {
	case gameconfig.EdgeMathVersions:
		m.ClearMathVersions()
		return nil
	case gameconfig.EdgeGameVersions:
		m.ClearGameVersions()
		return nil
	case gameconfig.EdgeGames:
		m.ClearGames()
		return nil
	case gameconfig.EdgeOperator:
		m.ClearOperator()
		return nil
	case gameconfig.EdgeCurrencyVersions:
		m.ClearCurrencyVersions()
		return nil
	}
	return fmt.Errorf("unknown GameConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameConfigMutation) ResetEdge(name string) error {
	switch name {
	case gameconfig.EdgeMathVersions:
		m.ResetMathVersions()
		return nil
	case gameconfig.EdgeGameVersions:
		m.ResetGameVersions()
		return nil
	case gameconfig.EdgeGames:
		m.ResetGames()
		return nil
	case gameconfig.EdgeOperator:
		m.ResetOperator()
		return nil
	case gameconfig.EdgeCurrencyVersions:
		m.ResetCurrencyVersions()
		return nil
	}
	return fmt.Errorf("unknown GameConfig edge %s", name)
}

// GameFeatureMutation represents an operation that mutates the GameFeature nodes in the graph.
type GameFeatureMutation struct {
	config
	op              Op
	typ             string
	id              *int
	clearedFields   map[string]struct{}
	features        *int
	clearedfeatures bool
	games           *int
	clearedgames    bool
	done            bool
	oldValue        func(context.Context) (*GameFeature, error)
	predicates      []predicate.GameFeature
}

var _ ent.Mutation = (*GameFeatureMutation)(nil)

// gamefeatureOption allows management of the mutation configuration using functional options.
type gamefeatureOption func(*GameFeatureMutation)

// newGameFeatureMutation creates new mutation for the GameFeature entity.
func newGameFeatureMutation(c config, op Op, opts ...gamefeatureOption) *GameFeatureMutation {
	m := &GameFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeGameFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameFeatureID sets the ID field of the mutation.
func withGameFeatureID(id int) gamefeatureOption {
	return func(m *GameFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *GameFeature
		)
		m.oldValue = func(ctx context.Context) (*GameFeature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameFeature sets the old GameFeature of the mutation.
func withGameFeature(node *GameFeature) gamefeatureOption {
	return func(m *GameFeatureMutation) {
		m.oldValue = func(context.Context) (*GameFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameFeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameFeatureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameFeature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeaturesID sets the "features" edge to the Feature entity by id.
func (m *GameFeatureMutation) SetFeaturesID(id int) {
	m.features = &id
}

// ClearFeatures clears the "features" edge to the Feature entity.
func (m *GameFeatureMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared reports if the "features" edge to the Feature entity was cleared.
func (m *GameFeatureMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// FeaturesID returns the "features" edge ID in the mutation.
func (m *GameFeatureMutation) FeaturesID() (id int, exists bool) {
	if m.features != nil {
		return *m.features, true
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *GameFeatureMutation) FeaturesIDs() (ids []int) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *GameFeatureMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// SetGamesID sets the "games" edge to the Game entity by id.
func (m *GameFeatureMutation) SetGamesID(id int) {
	m.games = &id
}

// ClearGames clears the "games" edge to the Game entity.
func (m *GameFeatureMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *GameFeatureMutation) GamesCleared() bool {
	return m.clearedgames
}

// GamesID returns the "games" edge ID in the mutation.
func (m *GameFeatureMutation) GamesID() (id int, exists bool) {
	if m.games != nil {
		return *m.games, true
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GamesID instead. It exists only for internal usage by the builders.
func (m *GameFeatureMutation) GamesIDs() (ids []int) {
	if id := m.games; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *GameFeatureMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
}

// Where appends a list predicates to the GameFeatureMutation builder.
func (m *GameFeatureMutation) Where(ps ...predicate.GameFeature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameFeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameFeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameFeature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameFeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameFeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameFeature).
func (m *GameFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameFeatureMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameFeatureMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown GameFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameFeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameFeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameFeatureMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown GameFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameFeatureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameFeatureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameFeatureMutation) ResetField(name string) error {
	return fmt.Errorf("unknown GameFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.features != nil {
		edges = append(edges, gamefeature.EdgeFeatures)
	}
	if m.games != nil {
		edges = append(edges, gamefeature.EdgeGames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gamefeature.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	case gamefeature.EdgeGames:
		if id := m.games; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameFeatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeatures {
		edges = append(edges, gamefeature.EdgeFeatures)
	}
	if m.clearedgames {
		edges = append(edges, gamefeature.EdgeGames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case gamefeature.EdgeFeatures:
		return m.clearedfeatures
	case gamefeature.EdgeGames:
		return m.clearedgames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameFeatureMutation) ClearEdge(name string) error {
	switch name {
	case gamefeature.EdgeFeatures:
		m.ClearFeatures()
		return nil
	case gamefeature.EdgeGames:
		m.ClearGames()
		return nil
	}
	return fmt.Errorf("unknown GameFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameFeatureMutation) ResetEdge(name string) error {
	switch name {
	case gamefeature.EdgeFeatures:
		m.ResetFeatures()
		return nil
	case gamefeature.EdgeGames:
		m.ResetGames()
		return nil
	}
	return fmt.Errorf("unknown GameFeature edge %s", name)
}

// GameTypeMutation represents an operation that mutates the GameType nodes in the graph.
type GameTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_type                    *string
	external_type_id         *string
	clearedFields            map[string]struct{}
	games                    map[int]struct{}
	removedgames             map[int]struct{}
	clearedgames             bool
	game_versions            map[int]struct{}
	removedgame_versions     map[int]struct{}
	clearedgame_versions     bool
	currency_versions        map[int]struct{}
	removedcurrency_versions map[int]struct{}
	clearedcurrency_versions bool
	done                     bool
	oldValue                 func(context.Context) (*GameType, error)
	predicates               []predicate.GameType
}

var _ ent.Mutation = (*GameTypeMutation)(nil)

// gametypeOption allows management of the mutation configuration using functional options.
type gametypeOption func(*GameTypeMutation)

// newGameTypeMutation creates new mutation for the GameType entity.
func newGameTypeMutation(c config, op Op, opts ...gametypeOption) *GameTypeMutation {
	m := &GameTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeGameType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameTypeID sets the ID field of the mutation.
func withGameTypeID(id int) gametypeOption {
	return func(m *GameTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *GameType
		)
		m.oldValue = func(ctx context.Context) (*GameType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameType sets the old GameType of the mutation.
func withGameType(node *GameType) gametypeOption {
	return func(m *GameTypeMutation) {
		m.oldValue = func(context.Context) (*GameType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *GameTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *GameTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the GameType entity.
// If the GameType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *GameTypeMutation) ResetType() {
	m._type = nil
}

// SetExternalTypeID sets the "external_type_id" field.
func (m *GameTypeMutation) SetExternalTypeID(s string) {
	m.external_type_id = &s
}

// ExternalTypeID returns the value of the "external_type_id" field in the mutation.
func (m *GameTypeMutation) ExternalTypeID() (r string, exists bool) {
	v := m.external_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalTypeID returns the old "external_type_id" field's value of the GameType entity.
// If the GameType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameTypeMutation) OldExternalTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalTypeID: %w", err)
	}
	return oldValue.ExternalTypeID, nil
}

// ResetExternalTypeID resets all changes to the "external_type_id" field.
func (m *GameTypeMutation) ResetExternalTypeID() {
	m.external_type_id = nil
}

// AddGameIDs adds the "games" edge to the Game entity by ids.
func (m *GameTypeMutation) AddGameIDs(ids ...int) {
	if m.games == nil {
		m.games = make(map[int]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the Game entity.
func (m *GameTypeMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *GameTypeMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the Game entity by IDs.
func (m *GameTypeMutation) RemoveGameIDs(ids ...int) {
	if m.removedgames == nil {
		m.removedgames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the Game entity.
func (m *GameTypeMutation) RemovedGamesIDs() (ids []int) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *GameTypeMutation) GamesIDs() (ids []int) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *GameTypeMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// AddGameVersionIDs adds the "game_versions" edge to the GameVersion entity by ids.
func (m *GameTypeMutation) AddGameVersionIDs(ids ...int) {
	if m.game_versions == nil {
		m.game_versions = make(map[int]struct{})
	}
	for i := range ids {
		m.game_versions[ids[i]] = struct{}{}
	}
}

// ClearGameVersions clears the "game_versions" edge to the GameVersion entity.
func (m *GameTypeMutation) ClearGameVersions() {
	m.clearedgame_versions = true
}

// GameVersionsCleared reports if the "game_versions" edge to the GameVersion entity was cleared.
func (m *GameTypeMutation) GameVersionsCleared() bool {
	return m.clearedgame_versions
}

// RemoveGameVersionIDs removes the "game_versions" edge to the GameVersion entity by IDs.
func (m *GameTypeMutation) RemoveGameVersionIDs(ids ...int) {
	if m.removedgame_versions == nil {
		m.removedgame_versions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_versions, ids[i])
		m.removedgame_versions[ids[i]] = struct{}{}
	}
}

// RemovedGameVersions returns the removed IDs of the "game_versions" edge to the GameVersion entity.
func (m *GameTypeMutation) RemovedGameVersionsIDs() (ids []int) {
	for id := range m.removedgame_versions {
		ids = append(ids, id)
	}
	return
}

// GameVersionsIDs returns the "game_versions" edge IDs in the mutation.
func (m *GameTypeMutation) GameVersionsIDs() (ids []int) {
	for id := range m.game_versions {
		ids = append(ids, id)
	}
	return
}

// ResetGameVersions resets all changes to the "game_versions" edge.
func (m *GameTypeMutation) ResetGameVersions() {
	m.game_versions = nil
	m.clearedgame_versions = false
	m.removedgame_versions = nil
}

// AddCurrencyVersionIDs adds the "currency_versions" edge to the CurrencyVersion entity by ids.
func (m *GameTypeMutation) AddCurrencyVersionIDs(ids ...int) {
	if m.currency_versions == nil {
		m.currency_versions = make(map[int]struct{})
	}
	for i := range ids {
		m.currency_versions[ids[i]] = struct{}{}
	}
}

// ClearCurrencyVersions clears the "currency_versions" edge to the CurrencyVersion entity.
func (m *GameTypeMutation) ClearCurrencyVersions() {
	m.clearedcurrency_versions = true
}

// CurrencyVersionsCleared reports if the "currency_versions" edge to the CurrencyVersion entity was cleared.
func (m *GameTypeMutation) CurrencyVersionsCleared() bool {
	return m.clearedcurrency_versions
}

// RemoveCurrencyVersionIDs removes the "currency_versions" edge to the CurrencyVersion entity by IDs.
func (m *GameTypeMutation) RemoveCurrencyVersionIDs(ids ...int) {
	if m.removedcurrency_versions == nil {
		m.removedcurrency_versions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.currency_versions, ids[i])
		m.removedcurrency_versions[ids[i]] = struct{}{}
	}
}

// RemovedCurrencyVersions returns the removed IDs of the "currency_versions" edge to the CurrencyVersion entity.
func (m *GameTypeMutation) RemovedCurrencyVersionsIDs() (ids []int) {
	for id := range m.removedcurrency_versions {
		ids = append(ids, id)
	}
	return
}

// CurrencyVersionsIDs returns the "currency_versions" edge IDs in the mutation.
func (m *GameTypeMutation) CurrencyVersionsIDs() (ids []int) {
	for id := range m.currency_versions {
		ids = append(ids, id)
	}
	return
}

// ResetCurrencyVersions resets all changes to the "currency_versions" edge.
func (m *GameTypeMutation) ResetCurrencyVersions() {
	m.currency_versions = nil
	m.clearedcurrency_versions = false
	m.removedcurrency_versions = nil
}

// Where appends a list predicates to the GameTypeMutation builder.
func (m *GameTypeMutation) Where(ps ...predicate.GameType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameType).
func (m *GameTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, gametype.FieldType)
	}
	if m.external_type_id != nil {
		fields = append(fields, gametype.FieldExternalTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gametype.FieldType:
		return m.GetType()
	case gametype.FieldExternalTypeID:
		return m.ExternalTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gametype.FieldType:
		return m.OldType(ctx)
	case gametype.FieldExternalTypeID:
		return m.OldExternalTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown GameType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gametype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case gametype.FieldExternalTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown GameType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameTypeMutation) ResetField(name string) error {
	switch name {
	case gametype.FieldType:
		m.ResetType()
		return nil
	case gametype.FieldExternalTypeID:
		m.ResetExternalTypeID()
		return nil
	}
	return fmt.Errorf("unknown GameType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.games != nil {
		edges = append(edges, gametype.EdgeGames)
	}
	if m.game_versions != nil {
		edges = append(edges, gametype.EdgeGameVersions)
	}
	if m.currency_versions != nil {
		edges = append(edges, gametype.EdgeCurrencyVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gametype.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	case gametype.EdgeGameVersions:
		ids := make([]ent.Value, 0, len(m.game_versions))
		for id := range m.game_versions {
			ids = append(ids, id)
		}
		return ids
	case gametype.EdgeCurrencyVersions:
		ids := make([]ent.Value, 0, len(m.currency_versions))
		for id := range m.currency_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgames != nil {
		edges = append(edges, gametype.EdgeGames)
	}
	if m.removedgame_versions != nil {
		edges = append(edges, gametype.EdgeGameVersions)
	}
	if m.removedcurrency_versions != nil {
		edges = append(edges, gametype.EdgeCurrencyVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gametype.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	case gametype.EdgeGameVersions:
		ids := make([]ent.Value, 0, len(m.removedgame_versions))
		for id := range m.removedgame_versions {
			ids = append(ids, id)
		}
		return ids
	case gametype.EdgeCurrencyVersions:
		ids := make([]ent.Value, 0, len(m.removedcurrency_versions))
		for id := range m.removedcurrency_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgames {
		edges = append(edges, gametype.EdgeGames)
	}
	if m.clearedgame_versions {
		edges = append(edges, gametype.EdgeGameVersions)
	}
	if m.clearedcurrency_versions {
		edges = append(edges, gametype.EdgeCurrencyVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case gametype.EdgeGames:
		return m.clearedgames
	case gametype.EdgeGameVersions:
		return m.clearedgame_versions
	case gametype.EdgeCurrencyVersions:
		return m.clearedcurrency_versions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GameType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameTypeMutation) ResetEdge(name string) error {
	switch name {
	case gametype.EdgeGames:
		m.ResetGames()
		return nil
	case gametype.EdgeGameVersions:
		m.ResetGameVersions()
		return nil
	case gametype.EdgeCurrencyVersions:
		m.ResetCurrencyVersions()
		return nil
	}
	return fmt.Errorf("unknown GameType edge %s", name)
}

// GameVersionMutation represents an operation that mutates the GameVersion nodes in the graph.
type GameVersionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	version                       *string
	can_demo                      *bool
	can_tournament                *bool
	can_free_bets                 *bool
	can_drop_and_wins             *bool
	can_turbo                     *bool
	url_media_pack                *string
	url_release_note              *string
	deprecated                    *bool
	available_math_versions       *[]int
	appendavailable_math_versions []int
	can_auto_bet                  *bool
	url_game_manual               *string
	can_auto_cashout              *bool
	can_buy_bonus                 *bool
	can_ante_bet                  *bool
	clearedFields                 map[string]struct{}
	games                         *int
	clearedgames                  bool
	game_type                     *int
	clearedgame_type              bool
	sessions                      map[int]struct{}
	removedsessions               map[int]struct{}
	clearedsessions               bool
	game_configs                  map[int]struct{}
	removedgame_configs           map[int]struct{}
	clearedgame_configs           bool
	done                          bool
	oldValue                      func(context.Context) (*GameVersion, error)
	predicates                    []predicate.GameVersion
}

var _ ent.Mutation = (*GameVersionMutation)(nil)

// gameversionOption allows management of the mutation configuration using functional options.
type gameversionOption func(*GameVersionMutation)

// newGameVersionMutation creates new mutation for the GameVersion entity.
func newGameVersionMutation(c config, op Op, opts ...gameversionOption) *GameVersionMutation {
	m := &GameVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeGameVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameVersionID sets the ID field of the mutation.
func withGameVersionID(id int) gameversionOption {
	return func(m *GameVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *GameVersion
		)
		m.oldValue = func(ctx context.Context) (*GameVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameVersion sets the old GameVersion of the mutation.
func withGameVersion(node *GameVersion) gameversionOption {
	return func(m *GameVersionMutation) {
		m.oldValue = func(context.Context) (*GameVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *GameVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *GameVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *GameVersionMutation) ResetVersion() {
	m.version = nil
}

// SetCanDemo sets the "can_demo" field.
func (m *GameVersionMutation) SetCanDemo(b bool) {
	m.can_demo = &b
}

// CanDemo returns the value of the "can_demo" field in the mutation.
func (m *GameVersionMutation) CanDemo() (r bool, exists bool) {
	v := m.can_demo
	if v == nil {
		return
	}
	return *v, true
}

// OldCanDemo returns the old "can_demo" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanDemo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanDemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanDemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanDemo: %w", err)
	}
	return oldValue.CanDemo, nil
}

// ResetCanDemo resets all changes to the "can_demo" field.
func (m *GameVersionMutation) ResetCanDemo() {
	m.can_demo = nil
}

// SetCanTournament sets the "can_tournament" field.
func (m *GameVersionMutation) SetCanTournament(b bool) {
	m.can_tournament = &b
}

// CanTournament returns the value of the "can_tournament" field in the mutation.
func (m *GameVersionMutation) CanTournament() (r bool, exists bool) {
	v := m.can_tournament
	if v == nil {
		return
	}
	return *v, true
}

// OldCanTournament returns the old "can_tournament" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanTournament(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanTournament is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanTournament requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanTournament: %w", err)
	}
	return oldValue.CanTournament, nil
}

// ResetCanTournament resets all changes to the "can_tournament" field.
func (m *GameVersionMutation) ResetCanTournament() {
	m.can_tournament = nil
}

// SetCanFreeBets sets the "can_free_bets" field.
func (m *GameVersionMutation) SetCanFreeBets(b bool) {
	m.can_free_bets = &b
}

// CanFreeBets returns the value of the "can_free_bets" field in the mutation.
func (m *GameVersionMutation) CanFreeBets() (r bool, exists bool) {
	v := m.can_free_bets
	if v == nil {
		return
	}
	return *v, true
}

// OldCanFreeBets returns the old "can_free_bets" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanFreeBets(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanFreeBets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanFreeBets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanFreeBets: %w", err)
	}
	return oldValue.CanFreeBets, nil
}

// ResetCanFreeBets resets all changes to the "can_free_bets" field.
func (m *GameVersionMutation) ResetCanFreeBets() {
	m.can_free_bets = nil
}

// SetCanDropAndWins sets the "can_drop_and_wins" field.
func (m *GameVersionMutation) SetCanDropAndWins(b bool) {
	m.can_drop_and_wins = &b
}

// CanDropAndWins returns the value of the "can_drop_and_wins" field in the mutation.
func (m *GameVersionMutation) CanDropAndWins() (r bool, exists bool) {
	v := m.can_drop_and_wins
	if v == nil {
		return
	}
	return *v, true
}

// OldCanDropAndWins returns the old "can_drop_and_wins" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanDropAndWins(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanDropAndWins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanDropAndWins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanDropAndWins: %w", err)
	}
	return oldValue.CanDropAndWins, nil
}

// ResetCanDropAndWins resets all changes to the "can_drop_and_wins" field.
func (m *GameVersionMutation) ResetCanDropAndWins() {
	m.can_drop_and_wins = nil
}

// SetCanTurbo sets the "can_turbo" field.
func (m *GameVersionMutation) SetCanTurbo(b bool) {
	m.can_turbo = &b
}

// CanTurbo returns the value of the "can_turbo" field in the mutation.
func (m *GameVersionMutation) CanTurbo() (r bool, exists bool) {
	v := m.can_turbo
	if v == nil {
		return
	}
	return *v, true
}

// OldCanTurbo returns the old "can_turbo" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanTurbo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanTurbo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanTurbo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanTurbo: %w", err)
	}
	return oldValue.CanTurbo, nil
}

// ResetCanTurbo resets all changes to the "can_turbo" field.
func (m *GameVersionMutation) ResetCanTurbo() {
	m.can_turbo = nil
}

// SetURLMediaPack sets the "url_media_pack" field.
func (m *GameVersionMutation) SetURLMediaPack(s string) {
	m.url_media_pack = &s
}

// URLMediaPack returns the value of the "url_media_pack" field in the mutation.
func (m *GameVersionMutation) URLMediaPack() (r string, exists bool) {
	v := m.url_media_pack
	if v == nil {
		return
	}
	return *v, true
}

// OldURLMediaPack returns the old "url_media_pack" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldURLMediaPack(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLMediaPack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLMediaPack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLMediaPack: %w", err)
	}
	return oldValue.URLMediaPack, nil
}

// ResetURLMediaPack resets all changes to the "url_media_pack" field.
func (m *GameVersionMutation) ResetURLMediaPack() {
	m.url_media_pack = nil
}

// SetURLReleaseNote sets the "url_release_note" field.
func (m *GameVersionMutation) SetURLReleaseNote(s string) {
	m.url_release_note = &s
}

// URLReleaseNote returns the value of the "url_release_note" field in the mutation.
func (m *GameVersionMutation) URLReleaseNote() (r string, exists bool) {
	v := m.url_release_note
	if v == nil {
		return
	}
	return *v, true
}

// OldURLReleaseNote returns the old "url_release_note" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldURLReleaseNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLReleaseNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLReleaseNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLReleaseNote: %w", err)
	}
	return oldValue.URLReleaseNote, nil
}

// ResetURLReleaseNote resets all changes to the "url_release_note" field.
func (m *GameVersionMutation) ResetURLReleaseNote() {
	m.url_release_note = nil
}

// SetDeprecated sets the "deprecated" field.
func (m *GameVersionMutation) SetDeprecated(b bool) {
	m.deprecated = &b
}

// Deprecated returns the value of the "deprecated" field in the mutation.
func (m *GameVersionMutation) Deprecated() (r bool, exists bool) {
	v := m.deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeprecated returns the old "deprecated" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeprecated: %w", err)
	}
	return oldValue.Deprecated, nil
}

// ResetDeprecated resets all changes to the "deprecated" field.
func (m *GameVersionMutation) ResetDeprecated() {
	m.deprecated = nil
}

// SetAvailableMathVersions sets the "available_math_versions" field.
func (m *GameVersionMutation) SetAvailableMathVersions(i []int) {
	m.available_math_versions = &i
	m.appendavailable_math_versions = nil
}

// AvailableMathVersions returns the value of the "available_math_versions" field in the mutation.
func (m *GameVersionMutation) AvailableMathVersions() (r []int, exists bool) {
	v := m.available_math_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableMathVersions returns the old "available_math_versions" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldAvailableMathVersions(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableMathVersions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableMathVersions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableMathVersions: %w", err)
	}
	return oldValue.AvailableMathVersions, nil
}

// AppendAvailableMathVersions adds i to the "available_math_versions" field.
func (m *GameVersionMutation) AppendAvailableMathVersions(i []int) {
	m.appendavailable_math_versions = append(m.appendavailable_math_versions, i...)
}

// AppendedAvailableMathVersions returns the list of values that were appended to the "available_math_versions" field in this mutation.
func (m *GameVersionMutation) AppendedAvailableMathVersions() ([]int, bool) {
	if len(m.appendavailable_math_versions) == 0 {
		return nil, false
	}
	return m.appendavailable_math_versions, true
}

// ResetAvailableMathVersions resets all changes to the "available_math_versions" field.
func (m *GameVersionMutation) ResetAvailableMathVersions() {
	m.available_math_versions = nil
	m.appendavailable_math_versions = nil
}

// SetCanAutoBet sets the "can_auto_bet" field.
func (m *GameVersionMutation) SetCanAutoBet(b bool) {
	m.can_auto_bet = &b
}

// CanAutoBet returns the value of the "can_auto_bet" field in the mutation.
func (m *GameVersionMutation) CanAutoBet() (r bool, exists bool) {
	v := m.can_auto_bet
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAutoBet returns the old "can_auto_bet" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanAutoBet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAutoBet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAutoBet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAutoBet: %w", err)
	}
	return oldValue.CanAutoBet, nil
}

// ResetCanAutoBet resets all changes to the "can_auto_bet" field.
func (m *GameVersionMutation) ResetCanAutoBet() {
	m.can_auto_bet = nil
}

// SetURLGameManual sets the "url_game_manual" field.
func (m *GameVersionMutation) SetURLGameManual(s string) {
	m.url_game_manual = &s
}

// URLGameManual returns the value of the "url_game_manual" field in the mutation.
func (m *GameVersionMutation) URLGameManual() (r string, exists bool) {
	v := m.url_game_manual
	if v == nil {
		return
	}
	return *v, true
}

// OldURLGameManual returns the old "url_game_manual" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldURLGameManual(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLGameManual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLGameManual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLGameManual: %w", err)
	}
	return oldValue.URLGameManual, nil
}

// ResetURLGameManual resets all changes to the "url_game_manual" field.
func (m *GameVersionMutation) ResetURLGameManual() {
	m.url_game_manual = nil
}

// SetCanAutoCashout sets the "can_auto_cashout" field.
func (m *GameVersionMutation) SetCanAutoCashout(b bool) {
	m.can_auto_cashout = &b
}

// CanAutoCashout returns the value of the "can_auto_cashout" field in the mutation.
func (m *GameVersionMutation) CanAutoCashout() (r bool, exists bool) {
	v := m.can_auto_cashout
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAutoCashout returns the old "can_auto_cashout" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanAutoCashout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAutoCashout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAutoCashout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAutoCashout: %w", err)
	}
	return oldValue.CanAutoCashout, nil
}

// ResetCanAutoCashout resets all changes to the "can_auto_cashout" field.
func (m *GameVersionMutation) ResetCanAutoCashout() {
	m.can_auto_cashout = nil
}

// SetCanBuyBonus sets the "can_buy_bonus" field.
func (m *GameVersionMutation) SetCanBuyBonus(b bool) {
	m.can_buy_bonus = &b
}

// CanBuyBonus returns the value of the "can_buy_bonus" field in the mutation.
func (m *GameVersionMutation) CanBuyBonus() (r bool, exists bool) {
	v := m.can_buy_bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldCanBuyBonus returns the old "can_buy_bonus" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanBuyBonus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanBuyBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanBuyBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanBuyBonus: %w", err)
	}
	return oldValue.CanBuyBonus, nil
}

// ResetCanBuyBonus resets all changes to the "can_buy_bonus" field.
func (m *GameVersionMutation) ResetCanBuyBonus() {
	m.can_buy_bonus = nil
}

// SetCanAnteBet sets the "can_ante_bet" field.
func (m *GameVersionMutation) SetCanAnteBet(b bool) {
	m.can_ante_bet = &b
}

// CanAnteBet returns the value of the "can_ante_bet" field in the mutation.
func (m *GameVersionMutation) CanAnteBet() (r bool, exists bool) {
	v := m.can_ante_bet
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAnteBet returns the old "can_ante_bet" field's value of the GameVersion entity.
// If the GameVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameVersionMutation) OldCanAnteBet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAnteBet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAnteBet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAnteBet: %w", err)
	}
	return oldValue.CanAnteBet, nil
}

// ResetCanAnteBet resets all changes to the "can_ante_bet" field.
func (m *GameVersionMutation) ResetCanAnteBet() {
	m.can_ante_bet = nil
}

// SetGamesID sets the "games" edge to the Game entity by id.
func (m *GameVersionMutation) SetGamesID(id int) {
	m.games = &id
}

// ClearGames clears the "games" edge to the Game entity.
func (m *GameVersionMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *GameVersionMutation) GamesCleared() bool {
	return m.clearedgames
}

// GamesID returns the "games" edge ID in the mutation.
func (m *GameVersionMutation) GamesID() (id int, exists bool) {
	if m.games != nil {
		return *m.games, true
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GamesID instead. It exists only for internal usage by the builders.
func (m *GameVersionMutation) GamesIDs() (ids []int) {
	if id := m.games; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *GameVersionMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
}

// SetGameTypeID sets the "game_type" edge to the GameType entity by id.
func (m *GameVersionMutation) SetGameTypeID(id int) {
	m.game_type = &id
}

// ClearGameType clears the "game_type" edge to the GameType entity.
func (m *GameVersionMutation) ClearGameType() {
	m.clearedgame_type = true
}

// GameTypeCleared reports if the "game_type" edge to the GameType entity was cleared.
func (m *GameVersionMutation) GameTypeCleared() bool {
	return m.clearedgame_type
}

// GameTypeID returns the "game_type" edge ID in the mutation.
func (m *GameVersionMutation) GameTypeID() (id int, exists bool) {
	if m.game_type != nil {
		return *m.game_type, true
	}
	return
}

// GameTypeIDs returns the "game_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameTypeID instead. It exists only for internal usage by the builders.
func (m *GameVersionMutation) GameTypeIDs() (ids []int) {
	if id := m.game_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGameType resets all changes to the "game_type" edge.
func (m *GameVersionMutation) ResetGameType() {
	m.game_type = nil
	m.clearedgame_type = false
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *GameVersionMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *GameVersionMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *GameVersionMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *GameVersionMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *GameVersionMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *GameVersionMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *GameVersionMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by ids.
func (m *GameVersionMutation) AddGameConfigIDs(ids ...int) {
	if m.game_configs == nil {
		m.game_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.game_configs[ids[i]] = struct{}{}
	}
}

// ClearGameConfigs clears the "game_configs" edge to the GameConfig entity.
func (m *GameVersionMutation) ClearGameConfigs() {
	m.clearedgame_configs = true
}

// GameConfigsCleared reports if the "game_configs" edge to the GameConfig entity was cleared.
func (m *GameVersionMutation) GameConfigsCleared() bool {
	return m.clearedgame_configs
}

// RemoveGameConfigIDs removes the "game_configs" edge to the GameConfig entity by IDs.
func (m *GameVersionMutation) RemoveGameConfigIDs(ids ...int) {
	if m.removedgame_configs == nil {
		m.removedgame_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_configs, ids[i])
		m.removedgame_configs[ids[i]] = struct{}{}
	}
}

// RemovedGameConfigs returns the removed IDs of the "game_configs" edge to the GameConfig entity.
func (m *GameVersionMutation) RemovedGameConfigsIDs() (ids []int) {
	for id := range m.removedgame_configs {
		ids = append(ids, id)
	}
	return
}

// GameConfigsIDs returns the "game_configs" edge IDs in the mutation.
func (m *GameVersionMutation) GameConfigsIDs() (ids []int) {
	for id := range m.game_configs {
		ids = append(ids, id)
	}
	return
}

// ResetGameConfigs resets all changes to the "game_configs" edge.
func (m *GameVersionMutation) ResetGameConfigs() {
	m.game_configs = nil
	m.clearedgame_configs = false
	m.removedgame_configs = nil
}

// Where appends a list predicates to the GameVersionMutation builder.
func (m *GameVersionMutation) Where(ps ...predicate.GameVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameVersion).
func (m *GameVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameVersionMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.version != nil {
		fields = append(fields, gameversion.FieldVersion)
	}
	if m.can_demo != nil {
		fields = append(fields, gameversion.FieldCanDemo)
	}
	if m.can_tournament != nil {
		fields = append(fields, gameversion.FieldCanTournament)
	}
	if m.can_free_bets != nil {
		fields = append(fields, gameversion.FieldCanFreeBets)
	}
	if m.can_drop_and_wins != nil {
		fields = append(fields, gameversion.FieldCanDropAndWins)
	}
	if m.can_turbo != nil {
		fields = append(fields, gameversion.FieldCanTurbo)
	}
	if m.url_media_pack != nil {
		fields = append(fields, gameversion.FieldURLMediaPack)
	}
	if m.url_release_note != nil {
		fields = append(fields, gameversion.FieldURLReleaseNote)
	}
	if m.deprecated != nil {
		fields = append(fields, gameversion.FieldDeprecated)
	}
	if m.available_math_versions != nil {
		fields = append(fields, gameversion.FieldAvailableMathVersions)
	}
	if m.can_auto_bet != nil {
		fields = append(fields, gameversion.FieldCanAutoBet)
	}
	if m.url_game_manual != nil {
		fields = append(fields, gameversion.FieldURLGameManual)
	}
	if m.can_auto_cashout != nil {
		fields = append(fields, gameversion.FieldCanAutoCashout)
	}
	if m.can_buy_bonus != nil {
		fields = append(fields, gameversion.FieldCanBuyBonus)
	}
	if m.can_ante_bet != nil {
		fields = append(fields, gameversion.FieldCanAnteBet)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameversion.FieldVersion:
		return m.Version()
	case gameversion.FieldCanDemo:
		return m.CanDemo()
	case gameversion.FieldCanTournament:
		return m.CanTournament()
	case gameversion.FieldCanFreeBets:
		return m.CanFreeBets()
	case gameversion.FieldCanDropAndWins:
		return m.CanDropAndWins()
	case gameversion.FieldCanTurbo:
		return m.CanTurbo()
	case gameversion.FieldURLMediaPack:
		return m.URLMediaPack()
	case gameversion.FieldURLReleaseNote:
		return m.URLReleaseNote()
	case gameversion.FieldDeprecated:
		return m.Deprecated()
	case gameversion.FieldAvailableMathVersions:
		return m.AvailableMathVersions()
	case gameversion.FieldCanAutoBet:
		return m.CanAutoBet()
	case gameversion.FieldURLGameManual:
		return m.URLGameManual()
	case gameversion.FieldCanAutoCashout:
		return m.CanAutoCashout()
	case gameversion.FieldCanBuyBonus:
		return m.CanBuyBonus()
	case gameversion.FieldCanAnteBet:
		return m.CanAnteBet()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameversion.FieldVersion:
		return m.OldVersion(ctx)
	case gameversion.FieldCanDemo:
		return m.OldCanDemo(ctx)
	case gameversion.FieldCanTournament:
		return m.OldCanTournament(ctx)
	case gameversion.FieldCanFreeBets:
		return m.OldCanFreeBets(ctx)
	case gameversion.FieldCanDropAndWins:
		return m.OldCanDropAndWins(ctx)
	case gameversion.FieldCanTurbo:
		return m.OldCanTurbo(ctx)
	case gameversion.FieldURLMediaPack:
		return m.OldURLMediaPack(ctx)
	case gameversion.FieldURLReleaseNote:
		return m.OldURLReleaseNote(ctx)
	case gameversion.FieldDeprecated:
		return m.OldDeprecated(ctx)
	case gameversion.FieldAvailableMathVersions:
		return m.OldAvailableMathVersions(ctx)
	case gameversion.FieldCanAutoBet:
		return m.OldCanAutoBet(ctx)
	case gameversion.FieldURLGameManual:
		return m.OldURLGameManual(ctx)
	case gameversion.FieldCanAutoCashout:
		return m.OldCanAutoCashout(ctx)
	case gameversion.FieldCanBuyBonus:
		return m.OldCanBuyBonus(ctx)
	case gameversion.FieldCanAnteBet:
		return m.OldCanAnteBet(ctx)
	}
	return nil, fmt.Errorf("unknown GameVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case gameversion.FieldCanDemo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanDemo(v)
		return nil
	case gameversion.FieldCanTournament:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanTournament(v)
		return nil
	case gameversion.FieldCanFreeBets:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanFreeBets(v)
		return nil
	case gameversion.FieldCanDropAndWins:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanDropAndWins(v)
		return nil
	case gameversion.FieldCanTurbo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanTurbo(v)
		return nil
	case gameversion.FieldURLMediaPack:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLMediaPack(v)
		return nil
	case gameversion.FieldURLReleaseNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLReleaseNote(v)
		return nil
	case gameversion.FieldDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeprecated(v)
		return nil
	case gameversion.FieldAvailableMathVersions:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableMathVersions(v)
		return nil
	case gameversion.FieldCanAutoBet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAutoBet(v)
		return nil
	case gameversion.FieldURLGameManual:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLGameManual(v)
		return nil
	case gameversion.FieldCanAutoCashout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAutoCashout(v)
		return nil
	case gameversion.FieldCanBuyBonus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanBuyBonus(v)
		return nil
	case gameversion.FieldCanAnteBet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAnteBet(v)
		return nil
	}
	return fmt.Errorf("unknown GameVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameVersionMutation) ResetField(name string) error {
	switch name {
	case gameversion.FieldVersion:
		m.ResetVersion()
		return nil
	case gameversion.FieldCanDemo:
		m.ResetCanDemo()
		return nil
	case gameversion.FieldCanTournament:
		m.ResetCanTournament()
		return nil
	case gameversion.FieldCanFreeBets:
		m.ResetCanFreeBets()
		return nil
	case gameversion.FieldCanDropAndWins:
		m.ResetCanDropAndWins()
		return nil
	case gameversion.FieldCanTurbo:
		m.ResetCanTurbo()
		return nil
	case gameversion.FieldURLMediaPack:
		m.ResetURLMediaPack()
		return nil
	case gameversion.FieldURLReleaseNote:
		m.ResetURLReleaseNote()
		return nil
	case gameversion.FieldDeprecated:
		m.ResetDeprecated()
		return nil
	case gameversion.FieldAvailableMathVersions:
		m.ResetAvailableMathVersions()
		return nil
	case gameversion.FieldCanAutoBet:
		m.ResetCanAutoBet()
		return nil
	case gameversion.FieldURLGameManual:
		m.ResetURLGameManual()
		return nil
	case gameversion.FieldCanAutoCashout:
		m.ResetCanAutoCashout()
		return nil
	case gameversion.FieldCanBuyBonus:
		m.ResetCanBuyBonus()
		return nil
	case gameversion.FieldCanAnteBet:
		m.ResetCanAnteBet()
		return nil
	}
	return fmt.Errorf("unknown GameVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.games != nil {
		edges = append(edges, gameversion.EdgeGames)
	}
	if m.game_type != nil {
		edges = append(edges, gameversion.EdgeGameType)
	}
	if m.sessions != nil {
		edges = append(edges, gameversion.EdgeSessions)
	}
	if m.game_configs != nil {
		edges = append(edges, gameversion.EdgeGameConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameversion.EdgeGames:
		if id := m.games; id != nil {
			return []ent.Value{*id}
		}
	case gameversion.EdgeGameType:
		if id := m.game_type; id != nil {
			return []ent.Value{*id}
		}
	case gameversion.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case gameversion.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.game_configs))
		for id := range m.game_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsessions != nil {
		edges = append(edges, gameversion.EdgeSessions)
	}
	if m.removedgame_configs != nil {
		edges = append(edges, gameversion.EdgeGameConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gameversion.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case gameversion.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.removedgame_configs))
		for id := range m.removedgame_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgames {
		edges = append(edges, gameversion.EdgeGames)
	}
	if m.clearedgame_type {
		edges = append(edges, gameversion.EdgeGameType)
	}
	if m.clearedsessions {
		edges = append(edges, gameversion.EdgeSessions)
	}
	if m.clearedgame_configs {
		edges = append(edges, gameversion.EdgeGameConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case gameversion.EdgeGames:
		return m.clearedgames
	case gameversion.EdgeGameType:
		return m.clearedgame_type
	case gameversion.EdgeSessions:
		return m.clearedsessions
	case gameversion.EdgeGameConfigs:
		return m.clearedgame_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameVersionMutation) ClearEdge(name string) error {
	switch name {
	case gameversion.EdgeGames:
		m.ClearGames()
		return nil
	case gameversion.EdgeGameType:
		m.ClearGameType()
		return nil
	}
	return fmt.Errorf("unknown GameVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameVersionMutation) ResetEdge(name string) error {
	switch name {
	case gameversion.EdgeGames:
		m.ResetGames()
		return nil
	case gameversion.EdgeGameType:
		m.ResetGameType()
		return nil
	case gameversion.EdgeSessions:
		m.ResetSessions()
		return nil
	case gameversion.EdgeGameConfigs:
		m.ResetGameConfigs()
		return nil
	}
	return fmt.Errorf("unknown GameVersion edge %s", name)
}

// MathVersionMutation represents an operation that mutates the MathVersion nodes in the graph.
type MathVersionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	version             *string
	volatility          *int
	addvolatility       *int
	rtp                 *int
	addrtp              *int
	max_win             *int
	addmax_win          *int
	can_buy_bonus       *bool
	url_release_note    *string
	deprecated          *bool
	can_ante_bet        *bool
	clearedFields       map[string]struct{}
	sessions            map[int]struct{}
	removedsessions     map[int]struct{}
	clearedsessions     bool
	game_configs        map[int]struct{}
	removedgame_configs map[int]struct{}
	clearedgame_configs bool
	done                bool
	oldValue            func(context.Context) (*MathVersion, error)
	predicates          []predicate.MathVersion
}

var _ ent.Mutation = (*MathVersionMutation)(nil)

// mathversionOption allows management of the mutation configuration using functional options.
type mathversionOption func(*MathVersionMutation)

// newMathVersionMutation creates new mutation for the MathVersion entity.
func newMathVersionMutation(c config, op Op, opts ...mathversionOption) *MathVersionMutation {
	m := &MathVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeMathVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMathVersionID sets the ID field of the mutation.
func withMathVersionID(id int) mathversionOption {
	return func(m *MathVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *MathVersion
		)
		m.oldValue = func(ctx context.Context) (*MathVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MathVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMathVersion sets the old MathVersion of the mutation.
func withMathVersion(node *MathVersion) mathversionOption {
	return func(m *MathVersionMutation) {
		m.oldValue = func(context.Context) (*MathVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MathVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MathVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MathVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MathVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MathVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MathVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MathVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MathVersionMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *MathVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *MathVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *MathVersionMutation) ResetVersion() {
	m.version = nil
}

// SetVolatility sets the "volatility" field.
func (m *MathVersionMutation) SetVolatility(i int) {
	m.volatility = &i
	m.addvolatility = nil
}

// Volatility returns the value of the "volatility" field in the mutation.
func (m *MathVersionMutation) Volatility() (r int, exists bool) {
	v := m.volatility
	if v == nil {
		return
	}
	return *v, true
}

// OldVolatility returns the old "volatility" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldVolatility(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolatility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolatility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolatility: %w", err)
	}
	return oldValue.Volatility, nil
}

// AddVolatility adds i to the "volatility" field.
func (m *MathVersionMutation) AddVolatility(i int) {
	if m.addvolatility != nil {
		*m.addvolatility += i
	} else {
		m.addvolatility = &i
	}
}

// AddedVolatility returns the value that was added to the "volatility" field in this mutation.
func (m *MathVersionMutation) AddedVolatility() (r int, exists bool) {
	v := m.addvolatility
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolatility resets all changes to the "volatility" field.
func (m *MathVersionMutation) ResetVolatility() {
	m.volatility = nil
	m.addvolatility = nil
}

// SetRtp sets the "rtp" field.
func (m *MathVersionMutation) SetRtp(i int) {
	m.rtp = &i
	m.addrtp = nil
}

// Rtp returns the value of the "rtp" field in the mutation.
func (m *MathVersionMutation) Rtp() (r int, exists bool) {
	v := m.rtp
	if v == nil {
		return
	}
	return *v, true
}

// OldRtp returns the old "rtp" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldRtp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRtp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRtp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRtp: %w", err)
	}
	return oldValue.Rtp, nil
}

// AddRtp adds i to the "rtp" field.
func (m *MathVersionMutation) AddRtp(i int) {
	if m.addrtp != nil {
		*m.addrtp += i
	} else {
		m.addrtp = &i
	}
}

// AddedRtp returns the value that was added to the "rtp" field in this mutation.
func (m *MathVersionMutation) AddedRtp() (r int, exists bool) {
	v := m.addrtp
	if v == nil {
		return
	}
	return *v, true
}

// ResetRtp resets all changes to the "rtp" field.
func (m *MathVersionMutation) ResetRtp() {
	m.rtp = nil
	m.addrtp = nil
}

// SetMaxWin sets the "max_win" field.
func (m *MathVersionMutation) SetMaxWin(i int) {
	m.max_win = &i
	m.addmax_win = nil
}

// MaxWin returns the value of the "max_win" field in the mutation.
func (m *MathVersionMutation) MaxWin() (r int, exists bool) {
	v := m.max_win
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWin returns the old "max_win" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldMaxWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWin: %w", err)
	}
	return oldValue.MaxWin, nil
}

// AddMaxWin adds i to the "max_win" field.
func (m *MathVersionMutation) AddMaxWin(i int) {
	if m.addmax_win != nil {
		*m.addmax_win += i
	} else {
		m.addmax_win = &i
	}
}

// AddedMaxWin returns the value that was added to the "max_win" field in this mutation.
func (m *MathVersionMutation) AddedMaxWin() (r int, exists bool) {
	v := m.addmax_win
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxWin resets all changes to the "max_win" field.
func (m *MathVersionMutation) ResetMaxWin() {
	m.max_win = nil
	m.addmax_win = nil
}

// SetCanBuyBonus sets the "can_buy_bonus" field.
func (m *MathVersionMutation) SetCanBuyBonus(b bool) {
	m.can_buy_bonus = &b
}

// CanBuyBonus returns the value of the "can_buy_bonus" field in the mutation.
func (m *MathVersionMutation) CanBuyBonus() (r bool, exists bool) {
	v := m.can_buy_bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldCanBuyBonus returns the old "can_buy_bonus" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldCanBuyBonus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanBuyBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanBuyBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanBuyBonus: %w", err)
	}
	return oldValue.CanBuyBonus, nil
}

// ResetCanBuyBonus resets all changes to the "can_buy_bonus" field.
func (m *MathVersionMutation) ResetCanBuyBonus() {
	m.can_buy_bonus = nil
}

// SetURLReleaseNote sets the "url_release_note" field.
func (m *MathVersionMutation) SetURLReleaseNote(s string) {
	m.url_release_note = &s
}

// URLReleaseNote returns the value of the "url_release_note" field in the mutation.
func (m *MathVersionMutation) URLReleaseNote() (r string, exists bool) {
	v := m.url_release_note
	if v == nil {
		return
	}
	return *v, true
}

// OldURLReleaseNote returns the old "url_release_note" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldURLReleaseNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLReleaseNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLReleaseNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLReleaseNote: %w", err)
	}
	return oldValue.URLReleaseNote, nil
}

// ResetURLReleaseNote resets all changes to the "url_release_note" field.
func (m *MathVersionMutation) ResetURLReleaseNote() {
	m.url_release_note = nil
}

// SetDeprecated sets the "deprecated" field.
func (m *MathVersionMutation) SetDeprecated(b bool) {
	m.deprecated = &b
}

// Deprecated returns the value of the "deprecated" field in the mutation.
func (m *MathVersionMutation) Deprecated() (r bool, exists bool) {
	v := m.deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeprecated returns the old "deprecated" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeprecated: %w", err)
	}
	return oldValue.Deprecated, nil
}

// ResetDeprecated resets all changes to the "deprecated" field.
func (m *MathVersionMutation) ResetDeprecated() {
	m.deprecated = nil
}

// SetCanAnteBet sets the "can_ante_bet" field.
func (m *MathVersionMutation) SetCanAnteBet(b bool) {
	m.can_ante_bet = &b
}

// CanAnteBet returns the value of the "can_ante_bet" field in the mutation.
func (m *MathVersionMutation) CanAnteBet() (r bool, exists bool) {
	v := m.can_ante_bet
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAnteBet returns the old "can_ante_bet" field's value of the MathVersion entity.
// If the MathVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MathVersionMutation) OldCanAnteBet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAnteBet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAnteBet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAnteBet: %w", err)
	}
	return oldValue.CanAnteBet, nil
}

// ResetCanAnteBet resets all changes to the "can_ante_bet" field.
func (m *MathVersionMutation) ResetCanAnteBet() {
	m.can_ante_bet = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *MathVersionMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *MathVersionMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *MathVersionMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *MathVersionMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *MathVersionMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *MathVersionMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *MathVersionMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by ids.
func (m *MathVersionMutation) AddGameConfigIDs(ids ...int) {
	if m.game_configs == nil {
		m.game_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.game_configs[ids[i]] = struct{}{}
	}
}

// ClearGameConfigs clears the "game_configs" edge to the GameConfig entity.
func (m *MathVersionMutation) ClearGameConfigs() {
	m.clearedgame_configs = true
}

// GameConfigsCleared reports if the "game_configs" edge to the GameConfig entity was cleared.
func (m *MathVersionMutation) GameConfigsCleared() bool {
	return m.clearedgame_configs
}

// RemoveGameConfigIDs removes the "game_configs" edge to the GameConfig entity by IDs.
func (m *MathVersionMutation) RemoveGameConfigIDs(ids ...int) {
	if m.removedgame_configs == nil {
		m.removedgame_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_configs, ids[i])
		m.removedgame_configs[ids[i]] = struct{}{}
	}
}

// RemovedGameConfigs returns the removed IDs of the "game_configs" edge to the GameConfig entity.
func (m *MathVersionMutation) RemovedGameConfigsIDs() (ids []int) {
	for id := range m.removedgame_configs {
		ids = append(ids, id)
	}
	return
}

// GameConfigsIDs returns the "game_configs" edge IDs in the mutation.
func (m *MathVersionMutation) GameConfigsIDs() (ids []int) {
	for id := range m.game_configs {
		ids = append(ids, id)
	}
	return
}

// ResetGameConfigs resets all changes to the "game_configs" edge.
func (m *MathVersionMutation) ResetGameConfigs() {
	m.game_configs = nil
	m.clearedgame_configs = false
	m.removedgame_configs = nil
}

// Where appends a list predicates to the MathVersionMutation builder.
func (m *MathVersionMutation) Where(ps ...predicate.MathVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MathVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MathVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MathVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MathVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MathVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MathVersion).
func (m *MathVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MathVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, mathversion.FieldName)
	}
	if m.version != nil {
		fields = append(fields, mathversion.FieldVersion)
	}
	if m.volatility != nil {
		fields = append(fields, mathversion.FieldVolatility)
	}
	if m.rtp != nil {
		fields = append(fields, mathversion.FieldRtp)
	}
	if m.max_win != nil {
		fields = append(fields, mathversion.FieldMaxWin)
	}
	if m.can_buy_bonus != nil {
		fields = append(fields, mathversion.FieldCanBuyBonus)
	}
	if m.url_release_note != nil {
		fields = append(fields, mathversion.FieldURLReleaseNote)
	}
	if m.deprecated != nil {
		fields = append(fields, mathversion.FieldDeprecated)
	}
	if m.can_ante_bet != nil {
		fields = append(fields, mathversion.FieldCanAnteBet)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MathVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mathversion.FieldName:
		return m.Name()
	case mathversion.FieldVersion:
		return m.Version()
	case mathversion.FieldVolatility:
		return m.Volatility()
	case mathversion.FieldRtp:
		return m.Rtp()
	case mathversion.FieldMaxWin:
		return m.MaxWin()
	case mathversion.FieldCanBuyBonus:
		return m.CanBuyBonus()
	case mathversion.FieldURLReleaseNote:
		return m.URLReleaseNote()
	case mathversion.FieldDeprecated:
		return m.Deprecated()
	case mathversion.FieldCanAnteBet:
		return m.CanAnteBet()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MathVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mathversion.FieldName:
		return m.OldName(ctx)
	case mathversion.FieldVersion:
		return m.OldVersion(ctx)
	case mathversion.FieldVolatility:
		return m.OldVolatility(ctx)
	case mathversion.FieldRtp:
		return m.OldRtp(ctx)
	case mathversion.FieldMaxWin:
		return m.OldMaxWin(ctx)
	case mathversion.FieldCanBuyBonus:
		return m.OldCanBuyBonus(ctx)
	case mathversion.FieldURLReleaseNote:
		return m.OldURLReleaseNote(ctx)
	case mathversion.FieldDeprecated:
		return m.OldDeprecated(ctx)
	case mathversion.FieldCanAnteBet:
		return m.OldCanAnteBet(ctx)
	}
	return nil, fmt.Errorf("unknown MathVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MathVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mathversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mathversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case mathversion.FieldVolatility:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolatility(v)
		return nil
	case mathversion.FieldRtp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRtp(v)
		return nil
	case mathversion.FieldMaxWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWin(v)
		return nil
	case mathversion.FieldCanBuyBonus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanBuyBonus(v)
		return nil
	case mathversion.FieldURLReleaseNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLReleaseNote(v)
		return nil
	case mathversion.FieldDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeprecated(v)
		return nil
	case mathversion.FieldCanAnteBet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAnteBet(v)
		return nil
	}
	return fmt.Errorf("unknown MathVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MathVersionMutation) AddedFields() []string {
	var fields []string
	if m.addvolatility != nil {
		fields = append(fields, mathversion.FieldVolatility)
	}
	if m.addrtp != nil {
		fields = append(fields, mathversion.FieldRtp)
	}
	if m.addmax_win != nil {
		fields = append(fields, mathversion.FieldMaxWin)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MathVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mathversion.FieldVolatility:
		return m.AddedVolatility()
	case mathversion.FieldRtp:
		return m.AddedRtp()
	case mathversion.FieldMaxWin:
		return m.AddedMaxWin()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MathVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mathversion.FieldVolatility:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolatility(v)
		return nil
	case mathversion.FieldRtp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRtp(v)
		return nil
	case mathversion.FieldMaxWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxWin(v)
		return nil
	}
	return fmt.Errorf("unknown MathVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MathVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MathVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MathVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MathVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MathVersionMutation) ResetField(name string) error {
	switch name {
	case mathversion.FieldName:
		m.ResetName()
		return nil
	case mathversion.FieldVersion:
		m.ResetVersion()
		return nil
	case mathversion.FieldVolatility:
		m.ResetVolatility()
		return nil
	case mathversion.FieldRtp:
		m.ResetRtp()
		return nil
	case mathversion.FieldMaxWin:
		m.ResetMaxWin()
		return nil
	case mathversion.FieldCanBuyBonus:
		m.ResetCanBuyBonus()
		return nil
	case mathversion.FieldURLReleaseNote:
		m.ResetURLReleaseNote()
		return nil
	case mathversion.FieldDeprecated:
		m.ResetDeprecated()
		return nil
	case mathversion.FieldCanAnteBet:
		m.ResetCanAnteBet()
		return nil
	}
	return fmt.Errorf("unknown MathVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MathVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, mathversion.EdgeSessions)
	}
	if m.game_configs != nil {
		edges = append(edges, mathversion.EdgeGameConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MathVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mathversion.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case mathversion.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.game_configs))
		for id := range m.game_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MathVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, mathversion.EdgeSessions)
	}
	if m.removedgame_configs != nil {
		edges = append(edges, mathversion.EdgeGameConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MathVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mathversion.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case mathversion.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.removedgame_configs))
		for id := range m.removedgame_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MathVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, mathversion.EdgeSessions)
	}
	if m.clearedgame_configs {
		edges = append(edges, mathversion.EdgeGameConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MathVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case mathversion.EdgeSessions:
		return m.clearedsessions
	case mathversion.EdgeGameConfigs:
		return m.clearedgame_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MathVersionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MathVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MathVersionMutation) ResetEdge(name string) error {
	switch name {
	case mathversion.EdgeSessions:
		m.ResetSessions()
		return nil
	case mathversion.EdgeGameConfigs:
		m.ResetGameConfigs()
		return nil
	}
	return fmt.Errorf("unknown MathVersion edge %s", name)
}

// OperatorMutation represents an operation that mutates the Operator nodes in the graph.
type OperatorMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	created_at          *time.Time
	deleted_at          *time.Time
	alias               *string
	clearedFields       map[string]struct{}
	platforms           *int
	clearedplatforms    bool
	sessions            map[int]struct{}
	removedsessions     map[int]struct{}
	clearedsessions     bool
	game_configs        map[int]struct{}
	removedgame_configs map[int]struct{}
	clearedgame_configs bool
	done                bool
	oldValue            func(context.Context) (*Operator, error)
	predicates          []predicate.Operator
}

var _ ent.Mutation = (*OperatorMutation)(nil)

// operatorOption allows management of the mutation configuration using functional options.
type operatorOption func(*OperatorMutation)

// newOperatorMutation creates new mutation for the Operator entity.
func newOperatorMutation(c config, op Op, opts ...operatorOption) *OperatorMutation {
	m := &OperatorMutation{
		config:        c,
		op:            op,
		typ:           TypeOperator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperatorID sets the ID field of the mutation.
func withOperatorID(id int) operatorOption {
	return func(m *OperatorMutation) {
		var (
			err   error
			once  sync.Once
			value *Operator
		)
		m.oldValue = func(ctx context.Context) (*Operator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperator sets the old Operator of the mutation.
func withOperator(node *Operator) operatorOption {
	return func(m *OperatorMutation) {
		m.oldValue = func(context.Context) (*Operator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperatorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperatorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Operator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OperatorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OperatorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OperatorMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OperatorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OperatorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OperatorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OperatorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OperatorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OperatorMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[operator.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OperatorMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[operator.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OperatorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, operator.FieldDeletedAt)
}

// SetAlias sets the "alias" field.
func (m *OperatorMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *OperatorMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *OperatorMutation) ResetAlias() {
	m.alias = nil
}

// SetPlatformsID sets the "platforms" edge to the Platform entity by id.
func (m *OperatorMutation) SetPlatformsID(id int) {
	m.platforms = &id
}

// ClearPlatforms clears the "platforms" edge to the Platform entity.
func (m *OperatorMutation) ClearPlatforms() {
	m.clearedplatforms = true
}

// PlatformsCleared reports if the "platforms" edge to the Platform entity was cleared.
func (m *OperatorMutation) PlatformsCleared() bool {
	return m.clearedplatforms
}

// PlatformsID returns the "platforms" edge ID in the mutation.
func (m *OperatorMutation) PlatformsID() (id int, exists bool) {
	if m.platforms != nil {
		return *m.platforms, true
	}
	return
}

// PlatformsIDs returns the "platforms" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformsID instead. It exists only for internal usage by the builders.
func (m *OperatorMutation) PlatformsIDs() (ids []int) {
	if id := m.platforms; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatforms resets all changes to the "platforms" edge.
func (m *OperatorMutation) ResetPlatforms() {
	m.platforms = nil
	m.clearedplatforms = false
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *OperatorMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *OperatorMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *OperatorMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *OperatorMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *OperatorMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *OperatorMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *OperatorMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddGameConfigIDs adds the "game_configs" edge to the GameConfig entity by ids.
func (m *OperatorMutation) AddGameConfigIDs(ids ...int) {
	if m.game_configs == nil {
		m.game_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.game_configs[ids[i]] = struct{}{}
	}
}

// ClearGameConfigs clears the "game_configs" edge to the GameConfig entity.
func (m *OperatorMutation) ClearGameConfigs() {
	m.clearedgame_configs = true
}

// GameConfigsCleared reports if the "game_configs" edge to the GameConfig entity was cleared.
func (m *OperatorMutation) GameConfigsCleared() bool {
	return m.clearedgame_configs
}

// RemoveGameConfigIDs removes the "game_configs" edge to the GameConfig entity by IDs.
func (m *OperatorMutation) RemoveGameConfigIDs(ids ...int) {
	if m.removedgame_configs == nil {
		m.removedgame_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.game_configs, ids[i])
		m.removedgame_configs[ids[i]] = struct{}{}
	}
}

// RemovedGameConfigs returns the removed IDs of the "game_configs" edge to the GameConfig entity.
func (m *OperatorMutation) RemovedGameConfigsIDs() (ids []int) {
	for id := range m.removedgame_configs {
		ids = append(ids, id)
	}
	return
}

// GameConfigsIDs returns the "game_configs" edge IDs in the mutation.
func (m *OperatorMutation) GameConfigsIDs() (ids []int) {
	for id := range m.game_configs {
		ids = append(ids, id)
	}
	return
}

// ResetGameConfigs resets all changes to the "game_configs" edge.
func (m *OperatorMutation) ResetGameConfigs() {
	m.game_configs = nil
	m.clearedgame_configs = false
	m.removedgame_configs = nil
}

// Where appends a list predicates to the OperatorMutation builder.
func (m *OperatorMutation) Where(ps ...predicate.Operator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperatorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperatorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Operator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperatorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperatorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Operator).
func (m *OperatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperatorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, operator.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, operator.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, operator.FieldDeletedAt)
	}
	if m.alias != nil {
		fields = append(fields, operator.FieldAlias)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operator.FieldName:
		return m.Name()
	case operator.FieldCreatedAt:
		return m.CreatedAt()
	case operator.FieldDeletedAt:
		return m.DeletedAt()
	case operator.FieldAlias:
		return m.Alias()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operator.FieldName:
		return m.OldName(ctx)
	case operator.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operator.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case operator.FieldAlias:
		return m.OldAlias(ctx)
	}
	return nil, fmt.Errorf("unknown Operator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operator.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case operator.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operator.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case operator.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperatorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperatorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperatorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operator.FieldDeletedAt) {
		fields = append(fields, operator.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperatorMutation) ClearField(name string) error {
	switch name {
	case operator.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Operator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperatorMutation) ResetField(name string) error {
	switch name {
	case operator.FieldName:
		m.ResetName()
		return nil
	case operator.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operator.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case operator.FieldAlias:
		m.ResetAlias()
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.platforms != nil {
		edges = append(edges, operator.EdgePlatforms)
	}
	if m.sessions != nil {
		edges = append(edges, operator.EdgeSessions)
	}
	if m.game_configs != nil {
		edges = append(edges, operator.EdgeGameConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgePlatforms:
		if id := m.platforms; id != nil {
			return []ent.Value{*id}
		}
	case operator.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case operator.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.game_configs))
		for id := range m.game_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, operator.EdgeSessions)
	}
	if m.removedgame_configs != nil {
		edges = append(edges, operator.EdgeGameConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case operator.EdgeGameConfigs:
		ids := make([]ent.Value, 0, len(m.removedgame_configs))
		for id := range m.removedgame_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplatforms {
		edges = append(edges, operator.EdgePlatforms)
	}
	if m.clearedsessions {
		edges = append(edges, operator.EdgeSessions)
	}
	if m.clearedgame_configs {
		edges = append(edges, operator.EdgeGameConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperatorMutation) EdgeCleared(name string) bool {
	switch name {
	case operator.EdgePlatforms:
		return m.clearedplatforms
	case operator.EdgeSessions:
		return m.clearedsessions
	case operator.EdgeGameConfigs:
		return m.clearedgame_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperatorMutation) ClearEdge(name string) error {
	switch name {
	case operator.EdgePlatforms:
		m.ClearPlatforms()
		return nil
	}
	return fmt.Errorf("unknown Operator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperatorMutation) ResetEdge(name string) error {
	switch name {
	case operator.EdgePlatforms:
		m.ResetPlatforms()
		return nil
	case operator.EdgeSessions:
		m.ResetSessions()
		return nil
	case operator.EdgeGameConfigs:
		m.ResetGameConfigs()
		return nil
	}
	return fmt.Errorf("unknown Operator edge %s", name)
}

// PlatformMutation represents an operation that mutates the Platform nodes in the graph.
type PlatformMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	hash                *string
	created_at          *time.Time
	deleted_at          *time.Time
	home_button_payload *string
	clearedFields       map[string]struct{}
	_Operator           map[int]struct{}
	removed_Operator    map[int]struct{}
	cleared_Operator    bool
	done                bool
	oldValue            func(context.Context) (*Platform, error)
	predicates          []predicate.Platform
}

var _ ent.Mutation = (*PlatformMutation)(nil)

// platformOption allows management of the mutation configuration using functional options.
type platformOption func(*PlatformMutation)

// newPlatformMutation creates new mutation for the Platform entity.
func newPlatformMutation(c config, op Op, opts ...platformOption) *PlatformMutation {
	m := &PlatformMutation{
		config:        c,
		op:            op,
		typ:           TypePlatform,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformID sets the ID field of the mutation.
func withPlatformID(id int) platformOption {
	return func(m *PlatformMutation) {
		var (
			err   error
			once  sync.Once
			value *Platform
		)
		m.oldValue = func(ctx context.Context) (*Platform, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Platform.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatform sets the old Platform of the mutation.
func withPlatform(node *Platform) platformOption {
	return func(m *PlatformMutation) {
		m.oldValue = func(context.Context) (*Platform, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Platform.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlatformMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlatformMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Platform entity.
// If the Platform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlatformMutation) ResetName() {
	m.name = nil
}

// SetHash sets the "hash" field.
func (m *PlatformMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PlatformMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Platform entity.
// If the Platform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PlatformMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlatformMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlatformMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Platform entity.
// If the Platform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlatformMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlatformMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlatformMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Platform entity.
// If the Platform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlatformMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[platform.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlatformMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[platform.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlatformMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, platform.FieldDeletedAt)
}

// SetHomeButtonPayload sets the "home_button_payload" field.
func (m *PlatformMutation) SetHomeButtonPayload(s string) {
	m.home_button_payload = &s
}

// HomeButtonPayload returns the value of the "home_button_payload" field in the mutation.
func (m *PlatformMutation) HomeButtonPayload() (r string, exists bool) {
	v := m.home_button_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeButtonPayload returns the old "home_button_payload" field's value of the Platform entity.
// If the Platform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformMutation) OldHomeButtonPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeButtonPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeButtonPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeButtonPayload: %w", err)
	}
	return oldValue.HomeButtonPayload, nil
}

// ResetHomeButtonPayload resets all changes to the "home_button_payload" field.
func (m *PlatformMutation) ResetHomeButtonPayload() {
	m.home_button_payload = nil
}

// AddOperatorIDs adds the "Operator" edge to the Operator entity by ids.
func (m *PlatformMutation) AddOperatorIDs(ids ...int) {
	if m._Operator == nil {
		m._Operator = make(map[int]struct{})
	}
	for i := range ids {
		m._Operator[ids[i]] = struct{}{}
	}
}

// ClearOperator clears the "Operator" edge to the Operator entity.
func (m *PlatformMutation) ClearOperator() {
	m.cleared_Operator = true
}

// OperatorCleared reports if the "Operator" edge to the Operator entity was cleared.
func (m *PlatformMutation) OperatorCleared() bool {
	return m.cleared_Operator
}

// RemoveOperatorIDs removes the "Operator" edge to the Operator entity by IDs.
func (m *PlatformMutation) RemoveOperatorIDs(ids ...int) {
	if m.removed_Operator == nil {
		m.removed_Operator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Operator, ids[i])
		m.removed_Operator[ids[i]] = struct{}{}
	}
}

// RemovedOperator returns the removed IDs of the "Operator" edge to the Operator entity.
func (m *PlatformMutation) RemovedOperatorIDs() (ids []int) {
	for id := range m.removed_Operator {
		ids = append(ids, id)
	}
	return
}

// OperatorIDs returns the "Operator" edge IDs in the mutation.
func (m *PlatformMutation) OperatorIDs() (ids []int) {
	for id := range m._Operator {
		ids = append(ids, id)
	}
	return
}

// ResetOperator resets all changes to the "Operator" edge.
func (m *PlatformMutation) ResetOperator() {
	m._Operator = nil
	m.cleared_Operator = false
	m.removed_Operator = nil
}

// Where appends a list predicates to the PlatformMutation builder.
func (m *PlatformMutation) Where(ps ...predicate.Platform) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Platform, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Platform).
func (m *PlatformMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, platform.FieldName)
	}
	if m.hash != nil {
		fields = append(fields, platform.FieldHash)
	}
	if m.created_at != nil {
		fields = append(fields, platform.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, platform.FieldDeletedAt)
	}
	if m.home_button_payload != nil {
		fields = append(fields, platform.FieldHomeButtonPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platform.FieldName:
		return m.Name()
	case platform.FieldHash:
		return m.Hash()
	case platform.FieldCreatedAt:
		return m.CreatedAt()
	case platform.FieldDeletedAt:
		return m.DeletedAt()
	case platform.FieldHomeButtonPayload:
		return m.HomeButtonPayload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platform.FieldName:
		return m.OldName(ctx)
	case platform.FieldHash:
		return m.OldHash(ctx)
	case platform.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case platform.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case platform.FieldHomeButtonPayload:
		return m.OldHomeButtonPayload(ctx)
	}
	return nil, fmt.Errorf("unknown Platform field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platform.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case platform.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case platform.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case platform.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case platform.FieldHomeButtonPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeButtonPayload(v)
		return nil
	}
	return fmt.Errorf("unknown Platform field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Platform numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(platform.FieldDeletedAt) {
		fields = append(fields, platform.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformMutation) ClearField(name string) error {
	switch name {
	case platform.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Platform nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformMutation) ResetField(name string) error {
	switch name {
	case platform.FieldName:
		m.ResetName()
		return nil
	case platform.FieldHash:
		m.ResetHash()
		return nil
	case platform.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case platform.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case platform.FieldHomeButtonPayload:
		m.ResetHomeButtonPayload()
		return nil
	}
	return fmt.Errorf("unknown Platform field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Operator != nil {
		edges = append(edges, platform.EdgeOperator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platform.EdgeOperator:
		ids := make([]ent.Value, 0, len(m._Operator))
		for id := range m._Operator {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Operator != nil {
		edges = append(edges, platform.EdgeOperator)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platform.EdgeOperator:
		ids := make([]ent.Value, 0, len(m.removed_Operator))
		for id := range m.removed_Operator {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Operator {
		edges = append(edges, platform.EdgeOperator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformMutation) EdgeCleared(name string) bool {
	switch name {
	case platform.EdgeOperator:
		return m.cleared_Operator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Platform unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformMutation) ResetEdge(name string) error {
	switch name {
	case platform.EdgeOperator:
		m.ResetOperator()
		return nil
	}
	return fmt.Errorf("unknown Platform edge %s", name)
}

// SerieMutation represents an operation that mutates the Serie nodes in the graph.
type SerieMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	created_at            *time.Time
	deleted_at            *time.Time
	external_id           *string
	clearedFields         map[string]struct{}
	games                 map[int]struct{}
	removedgames          map[int]struct{}
	clearedgames          bool
	serie_features        map[int]struct{}
	removedserie_features map[int]struct{}
	clearedserie_features bool
	done                  bool
	oldValue              func(context.Context) (*Serie, error)
	predicates            []predicate.Serie
}

var _ ent.Mutation = (*SerieMutation)(nil)

// serieOption allows management of the mutation configuration using functional options.
type serieOption func(*SerieMutation)

// newSerieMutation creates new mutation for the Serie entity.
func newSerieMutation(c config, op Op, opts ...serieOption) *SerieMutation {
	m := &SerieMutation{
		config:        c,
		op:            op,
		typ:           TypeSerie,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSerieID sets the ID field of the mutation.
func withSerieID(id int) serieOption {
	return func(m *SerieMutation) {
		var (
			err   error
			once  sync.Once
			value *Serie
		)
		m.oldValue = func(ctx context.Context) (*Serie, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Serie.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSerie sets the old Serie of the mutation.
func withSerie(node *Serie) serieOption {
	return func(m *SerieMutation) {
		m.oldValue = func(context.Context) (*Serie, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SerieMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SerieMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SerieMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SerieMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Serie.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SerieMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SerieMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Serie entity.
// If the Serie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerieMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SerieMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SerieMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SerieMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Serie entity.
// If the Serie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerieMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SerieMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SerieMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SerieMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Serie entity.
// If the Serie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerieMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SerieMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[serie.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SerieMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[serie.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SerieMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, serie.FieldDeletedAt)
}

// SetExternalID sets the "external_id" field.
func (m *SerieMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SerieMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Serie entity.
// If the Serie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SerieMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SerieMutation) ResetExternalID() {
	m.external_id = nil
}

// AddGameIDs adds the "games" edge to the Game entity by ids.
func (m *SerieMutation) AddGameIDs(ids ...int) {
	if m.games == nil {
		m.games = make(map[int]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the Game entity.
func (m *SerieMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *SerieMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the Game entity by IDs.
func (m *SerieMutation) RemoveGameIDs(ids ...int) {
	if m.removedgames == nil {
		m.removedgames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the Game entity.
func (m *SerieMutation) RemovedGamesIDs() (ids []int) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *SerieMutation) GamesIDs() (ids []int) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *SerieMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// AddSerieFeatureIDs adds the "serie_features" edge to the SerieFeature entity by ids.
func (m *SerieMutation) AddSerieFeatureIDs(ids ...int) {
	if m.serie_features == nil {
		m.serie_features = make(map[int]struct{})
	}
	for i := range ids {
		m.serie_features[ids[i]] = struct{}{}
	}
}

// ClearSerieFeatures clears the "serie_features" edge to the SerieFeature entity.
func (m *SerieMutation) ClearSerieFeatures() {
	m.clearedserie_features = true
}

// SerieFeaturesCleared reports if the "serie_features" edge to the SerieFeature entity was cleared.
func (m *SerieMutation) SerieFeaturesCleared() bool {
	return m.clearedserie_features
}

// RemoveSerieFeatureIDs removes the "serie_features" edge to the SerieFeature entity by IDs.
func (m *SerieMutation) RemoveSerieFeatureIDs(ids ...int) {
	if m.removedserie_features == nil {
		m.removedserie_features = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.serie_features, ids[i])
		m.removedserie_features[ids[i]] = struct{}{}
	}
}

// RemovedSerieFeatures returns the removed IDs of the "serie_features" edge to the SerieFeature entity.
func (m *SerieMutation) RemovedSerieFeaturesIDs() (ids []int) {
	for id := range m.removedserie_features {
		ids = append(ids, id)
	}
	return
}

// SerieFeaturesIDs returns the "serie_features" edge IDs in the mutation.
func (m *SerieMutation) SerieFeaturesIDs() (ids []int) {
	for id := range m.serie_features {
		ids = append(ids, id)
	}
	return
}

// ResetSerieFeatures resets all changes to the "serie_features" edge.
func (m *SerieMutation) ResetSerieFeatures() {
	m.serie_features = nil
	m.clearedserie_features = false
	m.removedserie_features = nil
}

// Where appends a list predicates to the SerieMutation builder.
func (m *SerieMutation) Where(ps ...predicate.Serie) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SerieMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SerieMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Serie, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SerieMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SerieMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Serie).
func (m *SerieMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SerieMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, serie.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, serie.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, serie.FieldDeletedAt)
	}
	if m.external_id != nil {
		fields = append(fields, serie.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SerieMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serie.FieldName:
		return m.Name()
	case serie.FieldCreatedAt:
		return m.CreatedAt()
	case serie.FieldDeletedAt:
		return m.DeletedAt()
	case serie.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SerieMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serie.FieldName:
		return m.OldName(ctx)
	case serie.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serie.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case serie.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Serie field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SerieMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serie.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case serie.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serie.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case serie.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Serie field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SerieMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SerieMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SerieMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Serie numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SerieMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serie.FieldDeletedAt) {
		fields = append(fields, serie.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SerieMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SerieMutation) ClearField(name string) error {
	switch name {
	case serie.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Serie nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SerieMutation) ResetField(name string) error {
	switch name {
	case serie.FieldName:
		m.ResetName()
		return nil
	case serie.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serie.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case serie.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown Serie field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SerieMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.games != nil {
		edges = append(edges, serie.EdgeGames)
	}
	if m.serie_features != nil {
		edges = append(edges, serie.EdgeSerieFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SerieMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serie.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	case serie.EdgeSerieFeatures:
		ids := make([]ent.Value, 0, len(m.serie_features))
		for id := range m.serie_features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SerieMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgames != nil {
		edges = append(edges, serie.EdgeGames)
	}
	if m.removedserie_features != nil {
		edges = append(edges, serie.EdgeSerieFeatures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SerieMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serie.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	case serie.EdgeSerieFeatures:
		ids := make([]ent.Value, 0, len(m.removedserie_features))
		for id := range m.removedserie_features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SerieMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgames {
		edges = append(edges, serie.EdgeGames)
	}
	if m.clearedserie_features {
		edges = append(edges, serie.EdgeSerieFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SerieMutation) EdgeCleared(name string) bool {
	switch name {
	case serie.EdgeGames:
		return m.clearedgames
	case serie.EdgeSerieFeatures:
		return m.clearedserie_features
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SerieMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Serie unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SerieMutation) ResetEdge(name string) error {
	switch name {
	case serie.EdgeGames:
		m.ResetGames()
		return nil
	case serie.EdgeSerieFeatures:
		m.ResetSerieFeatures()
		return nil
	}
	return fmt.Errorf("unknown Serie edge %s", name)
}

// SerieFeatureMutation represents an operation that mutates the SerieFeature nodes in the graph.
type SerieFeatureMutation struct {
	config
	op              Op
	typ             string
	id              *int
	clearedFields   map[string]struct{}
	features        *int
	clearedfeatures bool
	series          *int
	clearedseries   bool
	done            bool
	oldValue        func(context.Context) (*SerieFeature, error)
	predicates      []predicate.SerieFeature
}

var _ ent.Mutation = (*SerieFeatureMutation)(nil)

// seriefeatureOption allows management of the mutation configuration using functional options.
type seriefeatureOption func(*SerieFeatureMutation)

// newSerieFeatureMutation creates new mutation for the SerieFeature entity.
func newSerieFeatureMutation(c config, op Op, opts ...seriefeatureOption) *SerieFeatureMutation {
	m := &SerieFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeSerieFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSerieFeatureID sets the ID field of the mutation.
func withSerieFeatureID(id int) seriefeatureOption {
	return func(m *SerieFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *SerieFeature
		)
		m.oldValue = func(ctx context.Context) (*SerieFeature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SerieFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSerieFeature sets the old SerieFeature of the mutation.
func withSerieFeature(node *SerieFeature) seriefeatureOption {
	return func(m *SerieFeatureMutation) {
		m.oldValue = func(context.Context) (*SerieFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SerieFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SerieFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SerieFeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SerieFeatureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SerieFeature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeaturesID sets the "features" edge to the Feature entity by id.
func (m *SerieFeatureMutation) SetFeaturesID(id int) {
	m.features = &id
}

// ClearFeatures clears the "features" edge to the Feature entity.
func (m *SerieFeatureMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared reports if the "features" edge to the Feature entity was cleared.
func (m *SerieFeatureMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// FeaturesID returns the "features" edge ID in the mutation.
func (m *SerieFeatureMutation) FeaturesID() (id int, exists bool) {
	if m.features != nil {
		return *m.features, true
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *SerieFeatureMutation) FeaturesIDs() (ids []int) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *SerieFeatureMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// SetSeriesID sets the "series" edge to the Serie entity by id.
func (m *SerieFeatureMutation) SetSeriesID(id int) {
	m.series = &id
}

// ClearSeries clears the "series" edge to the Serie entity.
func (m *SerieFeatureMutation) ClearSeries() {
	m.clearedseries = true
}

// SeriesCleared reports if the "series" edge to the Serie entity was cleared.
func (m *SerieFeatureMutation) SeriesCleared() bool {
	return m.clearedseries
}

// SeriesID returns the "series" edge ID in the mutation.
func (m *SerieFeatureMutation) SeriesID() (id int, exists bool) {
	if m.series != nil {
		return *m.series, true
	}
	return
}

// SeriesIDs returns the "series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeriesID instead. It exists only for internal usage by the builders.
func (m *SerieFeatureMutation) SeriesIDs() (ids []int) {
	if id := m.series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *SerieFeatureMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
}

// Where appends a list predicates to the SerieFeatureMutation builder.
func (m *SerieFeatureMutation) Where(ps ...predicate.SerieFeature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SerieFeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SerieFeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SerieFeature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SerieFeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SerieFeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SerieFeature).
func (m *SerieFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SerieFeatureMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SerieFeatureMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SerieFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown SerieFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SerieFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SerieFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SerieFeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SerieFeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SerieFeatureMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown SerieFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SerieFeatureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SerieFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SerieFeatureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SerieFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SerieFeatureMutation) ResetField(name string) error {
	return fmt.Errorf("unknown SerieFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SerieFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.features != nil {
		edges = append(edges, seriefeature.EdgeFeatures)
	}
	if m.series != nil {
		edges = append(edges, seriefeature.EdgeSeries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SerieFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seriefeature.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	case seriefeature.EdgeSeries:
		if id := m.series; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SerieFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SerieFeatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SerieFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeatures {
		edges = append(edges, seriefeature.EdgeFeatures)
	}
	if m.clearedseries {
		edges = append(edges, seriefeature.EdgeSeries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SerieFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case seriefeature.EdgeFeatures:
		return m.clearedfeatures
	case seriefeature.EdgeSeries:
		return m.clearedseries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SerieFeatureMutation) ClearEdge(name string) error {
	switch name {
	case seriefeature.EdgeFeatures:
		m.ClearFeatures()
		return nil
	case seriefeature.EdgeSeries:
		m.ClearSeries()
		return nil
	}
	return fmt.Errorf("unknown SerieFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SerieFeatureMutation) ResetEdge(name string) error {
	switch name {
	case seriefeature.EdgeFeatures:
		m.ResetFeatures()
		return nil
	case seriefeature.EdgeSeries:
		m.ResetSeries()
		return nil
	}
	return fmt.Errorf("unknown SerieFeature edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	can_demo                 *bool
	token                    *string
	client_id                *string
	demo                     *bool
	created_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	games                    *int
	clearedgames             bool
	game_versions            *int
	clearedgame_versions     bool
	_Operator                *int
	cleared_Operator         bool
	currency_versions        *int
	clearedcurrency_versions bool
	math_versions            *int
	clearedmath_versions     bool
	done                     bool
	oldValue                 func(context.Context) (*Session, error)
	predicates               []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCanDemo sets the "can_demo" field.
func (m *SessionMutation) SetCanDemo(b bool) {
	m.can_demo = &b
}

// CanDemo returns the value of the "can_demo" field in the mutation.
func (m *SessionMutation) CanDemo() (r bool, exists bool) {
	v := m.can_demo
	if v == nil {
		return
	}
	return *v, true
}

// OldCanDemo returns the old "can_demo" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCanDemo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanDemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanDemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanDemo: %w", err)
	}
	return oldValue.CanDemo, nil
}

// ResetCanDemo resets all changes to the "can_demo" field.
func (m *SessionMutation) ResetCanDemo() {
	m.can_demo = nil
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetClientID sets the "client_id" field.
func (m *SessionMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *SessionMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *SessionMutation) ResetClientID() {
	m.client_id = nil
}

// SetDemo sets the "demo" field.
func (m *SessionMutation) SetDemo(b bool) {
	m.demo = &b
}

// Demo returns the value of the "demo" field in the mutation.
func (m *SessionMutation) Demo() (r bool, exists bool) {
	v := m.demo
	if v == nil {
		return
	}
	return *v, true
}

// OldDemo returns the old "demo" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDemo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDemo: %w", err)
	}
	return oldValue.Demo, nil
}

// ResetDemo resets all changes to the "demo" field.
func (m *SessionMutation) ResetDemo() {
	m.demo = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[session.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, session.FieldDeletedAt)
}

// SetGamesID sets the "games" edge to the Game entity by id.
func (m *SessionMutation) SetGamesID(id int) {
	m.games = &id
}

// ClearGames clears the "games" edge to the Game entity.
func (m *SessionMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *SessionMutation) GamesCleared() bool {
	return m.clearedgames
}

// GamesID returns the "games" edge ID in the mutation.
func (m *SessionMutation) GamesID() (id int, exists bool) {
	if m.games != nil {
		return *m.games, true
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GamesID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) GamesIDs() (ids []int) {
	if id := m.games; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *SessionMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
}

// SetGameVersionsID sets the "game_versions" edge to the GameVersion entity by id.
func (m *SessionMutation) SetGameVersionsID(id int) {
	m.game_versions = &id
}

// ClearGameVersions clears the "game_versions" edge to the GameVersion entity.
func (m *SessionMutation) ClearGameVersions() {
	m.clearedgame_versions = true
}

// GameVersionsCleared reports if the "game_versions" edge to the GameVersion entity was cleared.
func (m *SessionMutation) GameVersionsCleared() bool {
	return m.clearedgame_versions
}

// GameVersionsID returns the "game_versions" edge ID in the mutation.
func (m *SessionMutation) GameVersionsID() (id int, exists bool) {
	if m.game_versions != nil {
		return *m.game_versions, true
	}
	return
}

// GameVersionsIDs returns the "game_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameVersionsID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) GameVersionsIDs() (ids []int) {
	if id := m.game_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGameVersions resets all changes to the "game_versions" edge.
func (m *SessionMutation) ResetGameVersions() {
	m.game_versions = nil
	m.clearedgame_versions = false
}

// SetOperatorID sets the "Operator" edge to the Operator entity by id.
func (m *SessionMutation) SetOperatorID(id int) {
	m._Operator = &id
}

// ClearOperator clears the "Operator" edge to the Operator entity.
func (m *SessionMutation) ClearOperator() {
	m.cleared_Operator = true
}

// OperatorCleared reports if the "Operator" edge to the Operator entity was cleared.
func (m *SessionMutation) OperatorCleared() bool {
	return m.cleared_Operator
}

// OperatorID returns the "Operator" edge ID in the mutation.
func (m *SessionMutation) OperatorID() (id int, exists bool) {
	if m._Operator != nil {
		return *m._Operator, true
	}
	return
}

// OperatorIDs returns the "Operator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatorID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) OperatorIDs() (ids []int) {
	if id := m._Operator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperator resets all changes to the "Operator" edge.
func (m *SessionMutation) ResetOperator() {
	m._Operator = nil
	m.cleared_Operator = false
}

// SetCurrencyVersionsID sets the "currency_versions" edge to the CurrencyVersion entity by id.
func (m *SessionMutation) SetCurrencyVersionsID(id int) {
	m.currency_versions = &id
}

// ClearCurrencyVersions clears the "currency_versions" edge to the CurrencyVersion entity.
func (m *SessionMutation) ClearCurrencyVersions() {
	m.clearedcurrency_versions = true
}

// CurrencyVersionsCleared reports if the "currency_versions" edge to the CurrencyVersion entity was cleared.
func (m *SessionMutation) CurrencyVersionsCleared() bool {
	return m.clearedcurrency_versions
}

// CurrencyVersionsID returns the "currency_versions" edge ID in the mutation.
func (m *SessionMutation) CurrencyVersionsID() (id int, exists bool) {
	if m.currency_versions != nil {
		return *m.currency_versions, true
	}
	return
}

// CurrencyVersionsIDs returns the "currency_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyVersionsID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) CurrencyVersionsIDs() (ids []int) {
	if id := m.currency_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrencyVersions resets all changes to the "currency_versions" edge.
func (m *SessionMutation) ResetCurrencyVersions() {
	m.currency_versions = nil
	m.clearedcurrency_versions = false
}

// SetMathVersionsID sets the "math_versions" edge to the MathVersion entity by id.
func (m *SessionMutation) SetMathVersionsID(id int) {
	m.math_versions = &id
}

// ClearMathVersions clears the "math_versions" edge to the MathVersion entity.
func (m *SessionMutation) ClearMathVersions() {
	m.clearedmath_versions = true
}

// MathVersionsCleared reports if the "math_versions" edge to the MathVersion entity was cleared.
func (m *SessionMutation) MathVersionsCleared() bool {
	return m.clearedmath_versions
}

// MathVersionsID returns the "math_versions" edge ID in the mutation.
func (m *SessionMutation) MathVersionsID() (id int, exists bool) {
	if m.math_versions != nil {
		return *m.math_versions, true
	}
	return
}

// MathVersionsIDs returns the "math_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MathVersionsID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) MathVersionsIDs() (ids []int) {
	if id := m.math_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMathVersions resets all changes to the "math_versions" edge.
func (m *SessionMutation) ResetMathVersions() {
	m.math_versions = nil
	m.clearedmath_versions = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.can_demo != nil {
		fields = append(fields, session.FieldCanDemo)
	}
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.client_id != nil {
		fields = append(fields, session.FieldClientID)
	}
	if m.demo != nil {
		fields = append(fields, session.FieldDemo)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, session.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCanDemo:
		return m.CanDemo()
	case session.FieldToken:
		return m.Token()
	case session.FieldClientID:
		return m.ClientID()
	case session.FieldDemo:
		return m.Demo()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCanDemo:
		return m.OldCanDemo(ctx)
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldClientID:
		return m.OldClientID(ctx)
	case session.FieldDemo:
		return m.OldDemo(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCanDemo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanDemo(v)
		return nil
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case session.FieldDemo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDemo(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldDeletedAt) {
		fields = append(fields, session.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCanDemo:
		m.ResetCanDemo()
		return nil
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldClientID:
		m.ResetClientID()
		return nil
	case session.FieldDemo:
		m.ResetDemo()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.games != nil {
		edges = append(edges, session.EdgeGames)
	}
	if m.game_versions != nil {
		edges = append(edges, session.EdgeGameVersions)
	}
	if m._Operator != nil {
		edges = append(edges, session.EdgeOperator)
	}
	if m.currency_versions != nil {
		edges = append(edges, session.EdgeCurrencyVersions)
	}
	if m.math_versions != nil {
		edges = append(edges, session.EdgeMathVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeGames:
		if id := m.games; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeGameVersions:
		if id := m.game_versions; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeOperator:
		if id := m._Operator; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeCurrencyVersions:
		if id := m.currency_versions; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeMathVersions:
		if id := m.math_versions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedgames {
		edges = append(edges, session.EdgeGames)
	}
	if m.clearedgame_versions {
		edges = append(edges, session.EdgeGameVersions)
	}
	if m.cleared_Operator {
		edges = append(edges, session.EdgeOperator)
	}
	if m.clearedcurrency_versions {
		edges = append(edges, session.EdgeCurrencyVersions)
	}
	if m.clearedmath_versions {
		edges = append(edges, session.EdgeMathVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeGames:
		return m.clearedgames
	case session.EdgeGameVersions:
		return m.clearedgame_versions
	case session.EdgeOperator:
		return m.cleared_Operator
	case session.EdgeCurrencyVersions:
		return m.clearedcurrency_versions
	case session.EdgeMathVersions:
		return m.clearedmath_versions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeGames:
		m.ClearGames()
		return nil
	case session.EdgeGameVersions:
		m.ClearGameVersions()
		return nil
	case session.EdgeOperator:
		m.ClearOperator()
		return nil
	case session.EdgeCurrencyVersions:
		m.ClearCurrencyVersions()
		return nil
	case session.EdgeMathVersions:
		m.ClearMathVersions()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeGames:
		m.ResetGames()
		return nil
	case session.EdgeGameVersions:
		m.ResetGameVersions()
		return nil
	case session.EdgeOperator:
		m.ResetOperator()
		return nil
	case session.EdgeCurrencyVersions:
		m.ResetCurrencyVersions()
		return nil
	case session.EdgeMathVersions:
		m.ResetMathVersions()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// StudioMutation represents an operation that mutates the Studio nodes in the graph.
type StudioMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	created_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	games         map[int]struct{}
	removedgames  map[int]struct{}
	clearedgames  bool
	done          bool
	oldValue      func(context.Context) (*Studio, error)
	predicates    []predicate.Studio
}

var _ ent.Mutation = (*StudioMutation)(nil)

// studioOption allows management of the mutation configuration using functional options.
type studioOption func(*StudioMutation)

// newStudioMutation creates new mutation for the Studio entity.
func newStudioMutation(c config, op Op, opts ...studioOption) *StudioMutation {
	m := &StudioMutation{
		config:        c,
		op:            op,
		typ:           TypeStudio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudioID sets the ID field of the mutation.
func withStudioID(id int) studioOption {
	return func(m *StudioMutation) {
		var (
			err   error
			once  sync.Once
			value *Studio
		)
		m.oldValue = func(ctx context.Context) (*Studio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Studio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudio sets the old Studio of the mutation.
func withStudio(node *Studio) studioOption {
	return func(m *StudioMutation) {
		m.oldValue = func(context.Context) (*Studio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudioMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudioMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Studio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StudioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StudioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Studio entity.
// If the Studio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StudioMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StudioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StudioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Studio entity.
// If the Studio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudioMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StudioMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StudioMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StudioMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Studio entity.
// If the Studio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudioMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StudioMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[studio.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StudioMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[studio.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StudioMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, studio.FieldDeletedAt)
}

// AddGameIDs adds the "games" edge to the Game entity by ids.
func (m *StudioMutation) AddGameIDs(ids ...int) {
	if m.games == nil {
		m.games = make(map[int]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the Game entity.
func (m *StudioMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *StudioMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the Game entity by IDs.
func (m *StudioMutation) RemoveGameIDs(ids ...int) {
	if m.removedgames == nil {
		m.removedgames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the Game entity.
func (m *StudioMutation) RemovedGamesIDs() (ids []int) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *StudioMutation) GamesIDs() (ids []int) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *StudioMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// Where appends a list predicates to the StudioMutation builder.
func (m *StudioMutation) Where(ps ...predicate.Studio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Studio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Studio).
func (m *StudioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudioMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, studio.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, studio.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, studio.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case studio.FieldName:
		return m.Name()
	case studio.FieldCreatedAt:
		return m.CreatedAt()
	case studio.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case studio.FieldName:
		return m.OldName(ctx)
	case studio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case studio.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Studio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case studio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case studio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case studio.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Studio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Studio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(studio.FieldDeletedAt) {
		fields = append(fields, studio.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudioMutation) ClearField(name string) error {
	switch name {
	case studio.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Studio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudioMutation) ResetField(name string) error {
	switch name {
	case studio.FieldName:
		m.ResetName()
		return nil
	case studio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case studio.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Studio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudioMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.games != nil {
		edges = append(edges, studio.EdgeGames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case studio.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgames != nil {
		edges = append(edges, studio.EdgeGames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case studio.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgames {
		edges = append(edges, studio.EdgeGames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudioMutation) EdgeCleared(name string) bool {
	switch name {
	case studio.EdgeGames:
		return m.clearedgames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudioMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Studio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudioMutation) ResetEdge(name string) error {
	switch name {
	case studio.EdgeGames:
		m.ResetGames()
		return nil
	}
	return fmt.Errorf("unknown Studio edge %s", name)
}
